{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define(\"exifr\", [\"exports\"], t) : t((e = e || self).exifr = {});\n}(this, function (e) {\n  \"use strict\";\n\n  function t(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function n(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n    }\n  }\n\n  function r(e, t, r) {\n    return t && n(e.prototype, t), r && n(e, r), e;\n  }\n\n  function i(e, t, n) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = n, e;\n  }\n\n  function s(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    });\n    var n = [\"prototype\", \"__proto__\", \"caller\", \"arguments\", \"length\", \"name\"];\n    Object.getOwnPropertyNames(t).forEach(function (r) {\n      -1 === n.indexOf(r) && e[r] !== t[r] && (e[r] = t[r]);\n    }), t && u(e, t);\n  }\n\n  function a(e) {\n    return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function u(e, t) {\n    return (u = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function o() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }\n\n  function f(e, t, n) {\n    return (f = o() ? Reflect.construct : function (e, t, n) {\n      var r = [null];\n      r.push.apply(r, t);\n      var i = new (Function.bind.apply(e, r))();\n      return n && u(i, n.prototype), i;\n    }).apply(null, arguments);\n  }\n\n  function h(e) {\n    var t = \"function\" == typeof Map ? new Map() : void 0;\n    return (h = function h(e) {\n      if (null === e || (n = e, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return e;\n      var n;\n      if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n      if (void 0 !== t) {\n        if (t.has(e)) return t.get(e);\n        t.set(e, r);\n      }\n\n      function r() {\n        return f(e, arguments, a(this).constructor);\n      }\n\n      return r.prototype = Object.create(e.prototype, {\n        constructor: {\n          value: r,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), u(r, e);\n    })(e);\n  }\n\n  function c(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n\n  function l(e, t) {\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? c(e) : t;\n  }\n\n  function d(e, t, n) {\n    return (d = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n      var r = function (e, t) {\n        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = a(e));) {\n          ;\n        }\n\n        return e;\n      }(e, t);\n\n      if (r) {\n        var i = Object.getOwnPropertyDescriptor(r, t);\n        return i.get ? i.get.call(n) : i.value;\n      }\n    })(e, t, n || e);\n  }\n\n  var v = Object.values || function (e) {\n    var t = [];\n\n    for (var n in e) {\n      t.push(e[n]);\n    }\n\n    return t;\n  },\n      p = Object.entries || function (e) {\n    var t = [];\n\n    for (var n in e) {\n      t.push([n, e[n]]);\n    }\n\n    return t;\n  },\n      y = Object.assign || function (e) {\n    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) {\n      n[r - 1] = arguments[r];\n    }\n\n    return n.forEach(function (t) {\n      for (var n in t) {\n        e[n] = t[n];\n      }\n    }), e;\n  },\n      g = Object.fromEntries || function (e) {\n    var t = {};\n    return k(e).forEach(function (e) {\n      var n = e[0],\n          r = e[1];\n      t[n] = r;\n    }), t;\n  },\n      k = Array.from || function (e) {\n    if (e instanceof S) {\n      var t = [];\n      return e.forEach(function (e, n) {\n        return t.push([n, e]);\n      }), t;\n    }\n\n    return Array.prototype.slice.call(e);\n  };\n\n  function m(e) {\n    return -1 !== this.indexOf(e);\n  }\n\n  Array.prototype.includes || (Array.prototype.includes = m), String.prototype.includes || (String.prototype.includes = m), String.prototype.startsWith || (String.prototype.startsWith = function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    return this.substring(t, t + e.length) === e;\n  }), String.prototype.endsWith || (String.prototype.endsWith = function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;\n    return this.substring(t - e.length, t) === e;\n  });\n\n  var b = \"undefined\" != typeof self ? self : global,\n      w = b.fetch || function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    return new Promise(function (n, r) {\n      var i = new XMLHttpRequest();\n      if (i.open(\"get\", e, !0), i.responseType = \"arraybuffer\", i.onerror = r, t.headers) for (var s in t.headers) {\n        i.setRequestHeader(s, t.headers[s]);\n      }\n      i.onload = function () {\n        n({\n          ok: i.status >= 200 && i.status < 300,\n          status: i.status,\n          arrayBuffer: function arrayBuffer() {\n            return Promise.resolve(i.response);\n          }\n        });\n      }, i.send(null);\n    });\n  },\n      A = function A(e) {\n    var t = [];\n    if (Object.defineProperties(t, {\n      size: {\n        get: function get() {\n          return this.length;\n        }\n      },\n      has: {\n        value: function value(e) {\n          return -1 !== this.indexOf(e);\n        }\n      },\n      add: {\n        value: function value(e) {\n          this.has(e) || this.push(e);\n        }\n      },\n      delete: {\n        value: function value(e) {\n          if (this.has(e)) {\n            var t = this.indexOf(e);\n            this.splice(t, 1);\n          }\n        }\n      }\n    }), Array.isArray(e)) for (var n = 0; n < e.length; n++) {\n      t.add(e[n]);\n    }\n    return t;\n  },\n      O = function O(e) {\n    return new S(e);\n  },\n      S = void 0 !== b.Map && void 0 !== b.Map.prototype.keys ? b.Map : function () {\n    function e(n) {\n      if (t(this, e), this.clear(), n) for (var r = 0; r < n.length; r++) {\n        this.set(n[r][0], n[r][1]);\n      }\n    }\n\n    return r(e, [{\n      key: \"clear\",\n      value: function value() {\n        this._map = {}, this._keys = [];\n      }\n    }, {\n      key: \"get\",\n      value: function value(e) {\n        return this._map[\"map_\" + e];\n      }\n    }, {\n      key: \"set\",\n      value: function value(e, t) {\n        return this._map[\"map_\" + e] = t, this._keys.indexOf(e) < 0 && this._keys.push(e), this;\n      }\n    }, {\n      key: \"has\",\n      value: function value(e) {\n        return this._keys.indexOf(e) >= 0;\n      }\n    }, {\n      key: \"delete\",\n      value: function value(e) {\n        var t = this._keys.indexOf(e);\n\n        return !(t < 0) && (delete this._map[\"map_\" + e], this._keys.splice(t, 1), !0);\n      }\n    }, {\n      key: \"keys\",\n      value: function value() {\n        return this._keys.slice(0);\n      }\n    }, {\n      key: \"values\",\n      value: function value() {\n        var e = this;\n        return this._keys.map(function (t) {\n          return e.get(t);\n        });\n      }\n    }, {\n      key: \"entries\",\n      value: function value() {\n        var e = this;\n        return this._keys.map(function (t) {\n          return [t, e.get(t)];\n        });\n      }\n    }, {\n      key: \"forEach\",\n      value: function value(e, t) {\n        for (var n = 0; n < this._keys.length; n++) {\n          e.call(t, this._map[\"map_\" + this._keys[n]], this._keys[n], this);\n        }\n      }\n    }, {\n      key: \"size\",\n      get: function get() {\n        return this._keys.length;\n      }\n    }]), e;\n  }(),\n      P = \"undefined\" != typeof self ? self : global,\n      U = \"undefined\" != typeof navigator,\n      x = U && \"undefined\" == typeof HTMLImageElement,\n      B = !(\"undefined\" == typeof global || \"undefined\" == typeof process || !process.versions || !process.versions.node),\n      C = P.Buffer,\n      j = P.BigInt,\n      _ = !!C;\n\n  var V = function V(e) {\n    return void 0 !== e;\n  };\n\n  function T(e) {\n    return void 0 === e || (e instanceof S ? 0 === e.size : 0 === v(e).filter(V).length);\n  }\n\n  function I(e) {\n    var t = new Error(e);\n    return delete t.stack, t;\n  }\n\n  function L(e) {\n    var t = function (e) {\n      var t = 0;\n      return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), e.ifd1.enabled && (t += 1024), t + 2048;\n    }(e);\n\n    return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), e.icc.enabled && (t += 6e3), t;\n  }\n\n  var z = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-8\") : void 0;\n\n  function F(e) {\n    return z ? z.decode(e) : _ ? Buffer.from(e).toString(\"utf8\") : decodeURIComponent(escape(String.fromCharCode.apply(null, e)));\n  }\n\n  var E = function () {\n    function e(n) {\n      var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n          i = arguments.length > 2 ? arguments[2] : void 0,\n          s = arguments.length > 3 ? arguments[3] : void 0;\n      if (t(this, e), \"boolean\" == typeof s && (this.le = s), Array.isArray(n) && (n = new Uint8Array(n)), 0 === n) this.byteOffset = 0, this.byteLength = 0;else if (n instanceof ArrayBuffer) {\n        void 0 === i && (i = n.byteLength - r);\n        var a = new DataView(n, r, i);\n\n        this._swapDataView(a);\n      } else if (n instanceof Uint8Array || n instanceof DataView || n instanceof e) {\n        if (void 0 === i && (i = n.byteLength - r), (r += n.byteOffset) + i > n.byteOffset + n.byteLength) throw I(\"Creating view outside of available memory in ArrayBuffer\");\n        var u = new DataView(n.buffer, r, i);\n\n        this._swapDataView(u);\n      } else {\n        if (\"number\" != typeof n) throw I(\"Invalid input argument for BufferView: \" + n);\n        var o = new DataView(new ArrayBuffer(n));\n\n        this._swapDataView(o);\n      }\n    }\n\n    return r(e, null, [{\n      key: \"from\",\n      value: function value(t, n) {\n        return t instanceof this && t.le === n ? t : new e(t, void 0, void 0, n);\n      }\n    }]), r(e, [{\n      key: \"_swapArrayBuffer\",\n      value: function value(e) {\n        this._swapDataView(new DataView(e));\n      }\n    }, {\n      key: \"_swapBuffer\",\n      value: function value(e) {\n        this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));\n      }\n    }, {\n      key: \"_swapDataView\",\n      value: function value(e) {\n        this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;\n      }\n    }, {\n      key: \"_lengthToEnd\",\n      value: function value(e) {\n        return this.byteLength - e;\n      }\n    }, {\n      key: \"set\",\n      value: function value(t, n) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e;\n        if (t instanceof DataView || t instanceof e ? t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer && (t = new Uint8Array(t)), !(t instanceof Uint8Array)) throw I(\"BufferView.set(): Invalid data argument.\");\n        var i = this.toUint8();\n        return i.set(t, n), new r(this, n, t.byteLength);\n      }\n    }, {\n      key: \"subarray\",\n      value: function value(t, n) {\n        return new e(this, t, n = n || this._lengthToEnd(t));\n      }\n    }, {\n      key: \"toUint8\",\n      value: function value() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);\n      }\n    }, {\n      key: \"getUint8Array\",\n      value: function value(e, t) {\n        return new Uint8Array(this.buffer, this.byteOffset + e, t);\n      }\n    }, {\n      key: \"getString\",\n      value: function value() {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength,\n            n = this.getUint8Array(e, t);\n        return F(n);\n      }\n    }, {\n      key: \"getUnicodeString\",\n      value: function value() {\n        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength, n = [], r = 0; r < t && e + r < this.byteLength; r += 2) {\n          n.push(this.getUint16(e + r));\n        }\n\n        return n.map(function (e) {\n          return String.fromCharCode(e);\n        }).join(\"\");\n      }\n    }, {\n      key: \"getInt8\",\n      value: function value(e) {\n        return this.dataView.getInt8(e);\n      }\n    }, {\n      key: \"getUint8\",\n      value: function value(e) {\n        return this.dataView.getUint8(e);\n      }\n    }, {\n      key: \"getInt16\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getInt16(e, t);\n      }\n    }, {\n      key: \"getInt32\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getInt32(e, t);\n      }\n    }, {\n      key: \"getUint16\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getUint16(e, t);\n      }\n    }, {\n      key: \"getUint32\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getUint32(e, t);\n      }\n    }, {\n      key: \"getFloat32\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat32(e, t);\n      }\n    }, {\n      key: \"getFloat64\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat64(e, t);\n      }\n    }, {\n      key: \"getFloat\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat32(e, t);\n      }\n    }, {\n      key: \"getDouble\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat64(e, t);\n      }\n    }, {\n      key: \"getUint64\",\n      value: function value(e) {\n        var t = this.getUint32(e),\n            n = this.getUint32(e + 4);\n        if (t < 1048575) return t << 32 | n;\n        if (void 0 !== typeof j) return console.warn(\"Using BigInt because of type 64uint but JS can only handle 53b numbers.\"), j(t) << j(32) | j(n);\n        throw I(\"Trying to read 64b value but JS can only handle 53b numbers.\");\n      }\n    }, {\n      key: \"getUintBytes\",\n      value: function value(e, t, n) {\n        switch (t) {\n          case 1:\n            return this.getUint8(e, n);\n\n          case 2:\n            return this.getUint16(e, n);\n\n          case 4:\n            return this.getUint32(e, n);\n\n          case 8:\n            return this.getUint64(e, n);\n        }\n      }\n    }, {\n      key: \"getUint\",\n      value: function value(e, t, n) {\n        switch (t) {\n          case 8:\n            return this.getUint8(e, n);\n\n          case 16:\n            return this.getUint16(e, n);\n\n          case 32:\n            return this.getUint32(e, n);\n\n          case 64:\n            return this.getUint64(e, n);\n        }\n      }\n    }, {\n      key: \"toString\",\n      value: function value(e) {\n        return this.dataView.toString(e, this.constructor.name);\n      }\n    }, {\n      key: \"ensureChunk\",\n      value: function value() {}\n    }]), e;\n  }();\n\n  function D(e, t) {\n    throw I(\"\".concat(e, \" '\").concat(t, \"' was not loaded, try using full build of exifr.\"));\n  }\n\n  var R = function (e) {\n    function n(e) {\n      var r;\n      return t(this, n), (r = l(this, a(n).call(this))).kind = e, r;\n    }\n\n    return s(n, e), r(n, [{\n      key: \"get\",\n      value: function value(e, t) {\n        return this.has(e) || D(this.kind, e), t && (e in t || function (e, t) {\n          throw I(\"Unknown \".concat(e, \" '\").concat(t, \"'.\"));\n        }(this.kind, e), t[e].enabled || D(this.kind, e)), d(a(n.prototype), \"get\", this).call(this, e);\n      }\n    }, {\n      key: \"keyList\",\n      value: function value() {\n        return k(this.keys());\n      }\n    }]), n;\n  }(h(S)),\n      N = new R(\"file parser\"),\n      M = new R(\"segment parser\"),\n      W = new R(\"file reader\");\n\n  function K(e) {\n    return function () {\n      for (var t = [], n = 0; n < arguments.length; n++) {\n        t[n] = arguments[n];\n      }\n\n      try {\n        return Promise.resolve(e.apply(this, t));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n  }\n\n  function H(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n\n  var G = K(function (e) {\n    return new Promise(function (t, n) {\n      var r = new FileReader();\n      r.onloadend = function () {\n        return t(r.result || new ArrayBuffer());\n      }, r.onerror = n, r.readAsArrayBuffer(e);\n    });\n  }),\n      J = K(function (e) {\n    return w(e).then(function (e) {\n      return e.arrayBuffer();\n    });\n  }),\n      X = K(function (e, t) {\n    return H(t(e), function (e) {\n      return new E(e);\n    });\n  }),\n      q = K(function (e, t, n) {\n    var r = new (W.get(n))(e, t);\n    return H(r.read(), function () {\n      return r;\n    });\n  }),\n      Q = K(function (e, t, n, r) {\n    if (W.has(n)) return q(e, t, n);\n    if (r) return X(e, r);\n    throw I(\"Parser \".concat(n, \" is not loaded\"));\n  });\n\n  function Y(e, t) {\n    if ((n = e).startsWith(\"data:\") || n.length > 1e4) return q(e, t, \"base64\");\n    if (U) return Q(e, t, \"url\", J);\n    if (B) return q(e, t, \"fs\");\n    throw I(\"Invalid input argument\");\n    var n;\n  }\n\n  var Z = function (e) {\n    function n() {\n      return t(this, n), l(this, a(n).apply(this, arguments));\n    }\n\n    return s(n, e), r(n, [{\n      key: \"tagKeys\",\n      get: function get() {\n        return this.allKeys || (this.allKeys = k(this.keys())), this.allKeys;\n      }\n    }, {\n      key: \"tagValues\",\n      get: function get() {\n        return this.allValues || (this.allValues = k(this.values())), this.allValues;\n      }\n    }]), n;\n  }(h(S));\n\n  function $(e, t, n) {\n    var r = new Z(),\n        i = n;\n    Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n    for (var s = 0; s < i.length; s++) {\n      var a = i[s],\n          u = a[0],\n          o = a[1];\n      r.set(u, o);\n    }\n\n    if (Array.isArray(t)) {\n      var f = t;\n      Array.isArray(f) || (\"function\" == typeof f.entries && (f = f.entries()), f = k(f));\n\n      for (var h = 0; h < f.length; h++) {\n        var c = f[h];\n        e.set(c, r);\n      }\n    } else e.set(t, r);\n\n    return r;\n  }\n\n  function ee(e, t, n) {\n    var r,\n        i = e.get(t),\n        s = n;\n    Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = k(s));\n\n    for (var a = 0; a < s.length; a++) {\n      r = s[a], i.set(r[0], r[1]);\n    }\n  }\n\n  var te = O(),\n      ne = O(),\n      re = O(),\n      ie = [\"chunked\", \"firstChunkSize\", \"firstChunkSizeNode\", \"firstChunkSizeBrowser\", \"chunkSize\", \"chunkLimit\"],\n      se = [\"jfif\", \"xmp\", \"icc\", \"iptc\"],\n      ae = [\"tiff\"].concat(se),\n      ue = [\"ifd0\", \"ifd1\", \"exif\", \"gps\", \"interop\"],\n      oe = [].concat(ae, ue),\n      fe = [\"makerNote\", \"userComment\"],\n      he = [\"translateKeys\", \"translateValues\", \"reviveValues\", \"multiSegment\"],\n      ce = [].concat(he, [\"sanitize\", \"mergeOutput\"]),\n      le = function () {\n    function e() {\n      t(this, e);\n    }\n\n    return r(e, [{\n      key: \"translate\",\n      get: function get() {\n        return this.translateKeys || this.translateValues || this.reviveValues;\n      }\n    }]), e;\n  }(),\n      de = function (e) {\n    function n(e, r, s, u) {\n      var o;\n      if (t(this, n), i(c(o = l(this, a(n).call(this))), \"enabled\", !1), i(c(o), \"skip\", A()), i(c(o), \"pick\", A()), i(c(o), \"deps\", A()), i(c(o), \"translateKeys\", !1), i(c(o), \"translateValues\", !1), i(c(o), \"reviveValues\", !1), o.key = e, o.enabled = r, o.parse = o.enabled, o.applyInheritables(u), o.canBeFiltered = ue.includes(e), o.canBeFiltered && (o.dict = te.get(e)), void 0 !== s) if (Array.isArray(s)) o.parse = o.enabled = !0, o.canBeFiltered && s.length > 0 && o.translateTagSet(s, o.pick);else if (\"object\" == typeof s) {\n        if (o.enabled = !0, o.parse = !1 !== s.parse, o.canBeFiltered) {\n          var f = s.pick,\n              h = s.skip;\n          f && f.length > 0 && o.translateTagSet(f, o.pick), h && h.length > 0 && o.translateTagSet(h, o.skip);\n        }\n\n        o.applyInheritables(s);\n      } else {\n        if (!0 !== s && !1 !== s) throw I(\"Invalid options argument: \".concat(s));\n        o.parse = o.enabled = s;\n      }\n      return o;\n    }\n\n    return s(n, e), r(n, [{\n      key: \"needed\",\n      get: function get() {\n        return this.enabled || this.deps.size > 0;\n      }\n    }]), r(n, [{\n      key: \"applyInheritables\",\n      value: function value(e) {\n        var t,\n            n,\n            r = he;\n        Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = k(r));\n\n        for (var i = 0; i < r.length; i++) {\n          void 0 !== (n = e[t = r[i]]) && (this[t] = n);\n        }\n      }\n    }, {\n      key: \"translateTagSet\",\n      value: function value(e, t) {\n        if (this.dict) {\n          var n,\n              r,\n              i = this.dict,\n              s = i.tagKeys,\n              a = i.tagValues,\n              u = e;\n          Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = k(u));\n\n          for (var o = 0; o < u.length; o++) {\n            \"string\" == typeof (n = u[o]) ? (-1 === (r = a.indexOf(n)) && (r = s.indexOf(Number(n))), -1 !== r && t.add(Number(s[r]))) : t.add(n);\n          }\n        } else {\n          var f = e;\n          Array.isArray(f) || (\"function\" == typeof f.entries && (f = f.entries()), f = k(f));\n\n          for (var h = 0; h < f.length; h++) {\n            var c = f[h];\n            t.add(c);\n          }\n        }\n      }\n    }, {\n      key: \"finalizeFilters\",\n      value: function value() {\n        !this.enabled && this.deps.size > 0 ? (this.enabled = !0, me(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && me(this.pick, this.deps);\n      }\n    }]), n;\n  }(le),\n      ve = {\n    jfif: !1,\n    tiff: !0,\n    xmp: !1,\n    icc: !1,\n    iptc: !1,\n    ifd0: !0,\n    ifd1: !1,\n    exif: !0,\n    gps: !0,\n    interop: !1,\n    makerNote: !1,\n    userComment: !1,\n    multiSegment: !1,\n    skip: [],\n    pick: [],\n    translateKeys: !0,\n    translateValues: !0,\n    reviveValues: !0,\n    sanitize: !0,\n    mergeOutput: !0,\n    silentErrors: !0,\n    chunked: !0,\n    firstChunkSize: void 0,\n    firstChunkSizeNode: 512,\n    firstChunkSizeBrowser: 65536,\n    chunkSize: 65536,\n    chunkLimit: 5\n  },\n      pe = O(),\n      ye = function (e) {\n    function n(e) {\n      var r;\n      if (t(this, n), r = l(this, a(n).call(this)), !0 === e) r.setupFromTrue();else if (void 0 === e) r.setupFromUndefined();else if (Array.isArray(e)) r.setupFromArray(e);else {\n        if (\"object\" != typeof e) throw I(\"Invalid options argument \".concat(e));\n        r.setupFromObject(e);\n      }\n      return void 0 === r.firstChunkSize && (r.firstChunkSize = U ? r.firstChunkSizeBrowser : r.firstChunkSizeNode), r.mergeOutput && (r.ifd1.enabled = !1), r.filterNestedSegmentTags(), r.traverseTiffDependencyTree(), r.checkLoadedPlugins(), r;\n    }\n\n    return s(n, e), r(n, null, [{\n      key: \"useCached\",\n      value: function value(e) {\n        var t = pe.get(e);\n        return void 0 !== t ? t : (t = new this(e), pe.set(e, t), t);\n      }\n    }]), r(n, [{\n      key: \"setupFromUndefined\",\n      value: function value() {\n        var e,\n            t = ie;\n        Array.isArray(t) || (\"function\" == typeof t.entries && (t = t.entries()), t = k(t));\n\n        for (var n = 0; n < t.length; n++) {\n          this[e = t[n]] = ve[e];\n        }\n\n        var r = ce;\n        Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = k(r));\n\n        for (var i = 0; i < r.length; i++) {\n          this[e = r[i]] = ve[e];\n        }\n\n        var s = fe;\n        Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = k(s));\n\n        for (var a = 0; a < s.length; a++) {\n          this[e = s[a]] = ve[e];\n        }\n\n        var u = oe;\n        Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = k(u));\n\n        for (var o = 0; o < u.length; o++) {\n          this[e = u[o]] = new de(e, ve[e], void 0, this);\n        }\n      }\n    }, {\n      key: \"setupFromTrue\",\n      value: function value() {\n        var e,\n            t = ie;\n        Array.isArray(t) || (\"function\" == typeof t.entries && (t = t.entries()), t = k(t));\n\n        for (var n = 0; n < t.length; n++) {\n          this[e = t[n]] = ve[e];\n        }\n\n        var r = ce;\n        Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = k(r));\n\n        for (var i = 0; i < r.length; i++) {\n          this[e = r[i]] = ve[e];\n        }\n\n        var s = fe;\n        Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = k(s));\n\n        for (var a = 0; a < s.length; a++) {\n          this[e = s[a]] = !0;\n        }\n\n        var u = oe;\n        Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = k(u));\n\n        for (var o = 0; o < u.length; o++) {\n          this[e = u[o]] = new de(e, !0, void 0, this);\n        }\n      }\n    }, {\n      key: \"setupFromArray\",\n      value: function value(e) {\n        var t,\n            n = ie;\n        Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n        for (var r = 0; r < n.length; r++) {\n          this[t = n[r]] = ve[t];\n        }\n\n        var i = ce;\n        Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n        for (var s = 0; s < i.length; s++) {\n          this[t = i[s]] = ve[t];\n        }\n\n        var a = fe;\n        Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = k(a));\n\n        for (var u = 0; u < a.length; u++) {\n          this[t = a[u]] = ve[t];\n        }\n\n        var o = oe;\n        Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = k(o));\n\n        for (var f = 0; f < o.length; f++) {\n          this[t = o[f]] = new de(t, !1, void 0, this);\n        }\n\n        this.setupGlobalFilters(e, void 0, ue);\n      }\n    }, {\n      key: \"setupFromObject\",\n      value: function value(e) {\n        var t;\n        ue.ifd0 = ue.ifd0 || ue.image, ue.ifd1 = ue.ifd1 || ue.thumbnail, y(this, e);\n        var n = ie;\n        Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n        for (var r = 0; r < n.length; r++) {\n          this[t = n[r]] = ke(e[t], ve[t]);\n        }\n\n        var i = ce;\n        Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n        for (var s = 0; s < i.length; s++) {\n          this[t = i[s]] = ke(e[t], ve[t]);\n        }\n\n        var a = fe;\n        Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = k(a));\n\n        for (var u = 0; u < a.length; u++) {\n          this[t = a[u]] = ke(e[t], ve[t]);\n        }\n\n        var o = ae;\n        Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = k(o));\n\n        for (var f = 0; f < o.length; f++) {\n          this[t = o[f]] = new de(t, ve[t], e[t], this);\n        }\n\n        var h = ue;\n        Array.isArray(h) || (\"function\" == typeof h.entries && (h = h.entries()), h = k(h));\n\n        for (var c = 0; c < h.length; c++) {\n          this[t = h[c]] = new de(t, ve[t], e[t], this.tiff);\n        }\n\n        this.setupGlobalFilters(e.pick, e.skip, ue, oe), !0 === e.tiff ? this.batchEnableWithBool(ue, !0) : !1 === e.tiff ? this.batchEnableWithUserValue(ue, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, ue) : \"object\" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, ue);\n      }\n    }, {\n      key: \"batchEnableWithBool\",\n      value: function value(e, t) {\n        var n = e;\n        Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n        for (var r = 0; r < n.length; r++) {\n          this[n[r]].enabled = t;\n        }\n      }\n    }, {\n      key: \"batchEnableWithUserValue\",\n      value: function value(e, t) {\n        var n = e;\n        Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n        for (var r = 0; r < n.length; r++) {\n          var i = n[r],\n              s = t[i];\n          this[i].enabled = !1 !== s && void 0 !== s;\n        }\n      }\n    }, {\n      key: \"setupGlobalFilters\",\n      value: function value(e, t, n) {\n        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : n;\n\n        if (e && e.length) {\n          var i = r;\n          Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n          for (var s = 0; s < i.length; s++) {\n            var a = i[s];\n            this[a].enabled = !1;\n          }\n\n          var u = ge(e, n),\n              o = u;\n          Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = k(o));\n\n          for (var f = 0; f < o.length; f++) {\n            var h = o[f],\n                c = h[0],\n                l = h[1];\n            me(this[c].pick, l), this[c].enabled = !0;\n          }\n        } else if (t && t.length) {\n          var d = ge(t, n),\n              v = d;\n          Array.isArray(v) || (\"function\" == typeof v.entries && (v = v.entries()), v = k(v));\n\n          for (var p = 0; p < v.length; p++) {\n            var y = v[p],\n                g = y[0],\n                m = y[1];\n            me(this[g].skip, m);\n          }\n        }\n      }\n    }, {\n      key: \"filterNestedSegmentTags\",\n      value: function value() {\n        var e = this.ifd0,\n            t = this.exif,\n            n = this.xmp,\n            r = this.iptc,\n            i = this.icc;\n        this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), n.enabled || e.skip.add(700), r.enabled || e.skip.add(33723), i.enabled || e.skip.add(34675);\n      }\n    }, {\n      key: \"traverseTiffDependencyTree\",\n      value: function value() {\n        var e = this,\n            t = this.ifd0,\n            n = this.exif,\n            r = this.gps;\n        this.interop.needed && (n.deps.add(40965), t.deps.add(40965)), n.needed && t.deps.add(34665), r.needed && t.deps.add(34853), this.tiff.enabled = ue.some(function (t) {\n          return !0 === e[t].enabled;\n        }) || this.makerNote || this.userComment;\n        var i = ue;\n        Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n        for (var s = 0; s < i.length; s++) {\n          this[i[s]].finalizeFilters();\n        }\n      }\n    }, {\n      key: \"checkLoadedPlugins\",\n      value: function value() {\n        var e = ae;\n        Array.isArray(e) || (\"function\" == typeof e.entries && (e = e.entries()), e = k(e));\n\n        for (var t = 0; t < e.length; t++) {\n          var n = e[t];\n          this[n].enabled && !M.has(n) && D(\"segment parser\", n);\n        }\n      }\n    }, {\n      key: \"onlyTiff\",\n      get: function get() {\n        var e = this;\n        return !se.map(function (t) {\n          return e[t].enabled;\n        }).some(function (e) {\n          return !0 === e;\n        }) && this.tiff.enabled;\n      }\n    }]), n;\n  }(le);\n\n  function ge(e, t) {\n    var n,\n        r,\n        i,\n        s = [],\n        a = t;\n    Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = k(a));\n\n    for (var u = 0; u < a.length; u++) {\n      r = a[u], n = [];\n      var o = te.get(r);\n      Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = k(o));\n\n      for (var f = 0; f < o.length; f++) {\n        i = o[f], (e.includes(i[0]) || e.includes(i[1])) && n.push(i[0]);\n      }\n\n      n.length && s.push([r, n]);\n    }\n\n    return s;\n  }\n\n  function ke(e, t) {\n    return void 0 !== e ? e : void 0 !== t ? t : void 0;\n  }\n\n  function me(e, t) {\n    var n = t;\n    Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n    for (var r = 0; r < n.length; r++) {\n      var i = n[r];\n      e.add(i);\n    }\n  }\n\n  i(ye, \"default\", ve);\n  var be = {\n    ifd0: !1,\n    ifd1: !1,\n    exif: !1,\n    gps: !1,\n    interop: !1,\n    sanitize: !1,\n    reviveValues: !0,\n    translateKeys: !1,\n    translateValues: !1,\n    mergeOutput: !1\n  },\n      we = y({}, be, {\n    firstChunkSize: 4e4,\n    gps: [1, 2, 3, 4]\n  }),\n      Ae = y({}, be, {\n    firstChunkSize: 4e4,\n    ifd0: [274]\n  }),\n      Oe = y({}, be, {\n    tiff: !1,\n    ifd1: !0,\n    mergeOutput: !1\n  });\n\n  function Se(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n\n  function Pe(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n\n  function Ue() {}\n\n  var xe = function () {\n    function e(n) {\n      t(this, e), i(this, \"parsers\", {}), this.options = ye.useCached(n);\n    }\n\n    return r(e, [{\n      key: \"setup\",\n      value: function value() {\n        if (!this.fileParser) {\n          var e,\n              t = this.file.getUint16(0);\n          if (18761 === t || 19789 === t) this.file.isTiff = !0, e = N.get(\"tiff\");else if (65496 === t) this.file.isJpeg = !0, e = N.get(\"jpeg\");else {\n            if (!function (e) {\n              if (0 !== e.getUint16(0)) return !1;\n              var t = e.getUint16(2);\n              if (t > 50) return !1;\n\n              for (var n = 16, r = []; n < t;) {\n                r.push(e.getString(n, 4)), n += 4;\n              }\n\n              return r.includes(\"heic\");\n            }(this.file)) throw I(\"Unknown file format\");\n            this.file.isHeic = !0, e = N.get(\"heic\");\n          }\n          this.fileParser = new e(this.options, this.file, this.parsers);\n        }\n      }\n    }, {\n      key: \"read\",\n      value: function value(e) {\n        try {\n          var t = this;\n          return Se(function (e, t) {\n            if (\"string\" == typeof e) return Y(e, t);\n            if (U && !x && e instanceof HTMLImageElement) return Y(e.src, t);\n            if (e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView) return new E(e);\n            if (U && e instanceof Blob) return Q(e, t, \"blob\", G);\n            throw I(\"Invalid input argument\");\n          }(e, t.options), function (e) {\n            t.file = e;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parse\",\n      value: function value() {\n        try {\n          var e = this;\n          return e.setup(), Se(e.fileParser.parse(), function () {\n            var t,\n                n = {},\n                r = [],\n                i = v(e.parsers).map((t = function t(_t) {\n              var i;\n              return Pe(function () {\n                return e.options.silentErrors ? (n = function (e, t) {\n                  try {\n                    var n = e();\n                  } catch (e) {\n                    return t(e);\n                  }\n\n                  return n && n.then ? n.then(void 0, t) : n;\n                }(function () {\n                  return Se(_t.parse(), function (e) {\n                    i = e;\n                  });\n                }, function (e) {\n                  r.push(e);\n                }), s = function s() {\n                  _t.errors.length && r.push.apply(r, _t.errors);\n                }, n && n.then ? n.then(s) : s(n)) : Se(_t.parse(), function (e) {\n                  i = e;\n                });\n                var n, s;\n              }, function () {\n                _t.assignToOutput(n, i);\n              });\n            }, function () {\n              for (var e = [], n = 0; n < arguments.length; n++) {\n                e[n] = arguments[n];\n              }\n\n              try {\n                return Promise.resolve(t.apply(this, e));\n              } catch (e) {\n                return Promise.reject(e);\n              }\n            }));\n            return Se(Promise.all(i), function () {\n              var t;\n              return e.options.silentErrors && r.length > 0 && (n.errors = r), n = T(t = n) ? void 0 : t, e.file.close && e.file.close(), n;\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"extractThumbnail\",\n      value: function value() {\n        try {\n          var e = this;\n          e.setup();\n          var t,\n              n = M.get(\"tiff\", e.options);\n          return Pe(function () {\n            if (!e.file.isTiff) return function (e) {\n              var t = e();\n              if (t && t.then) return t.then(Ue);\n            }(function () {\n              if (e.file.isJpeg) return Se(e.fileParser.getOrFindSegment(\"tiff\"), function (e) {\n                t = e;\n              });\n            });\n            t = {\n              start: 0,\n              type: \"tiff\"\n            };\n          }, function () {\n            if (void 0 !== t) return Se(e.fileParser.ensureSegmentChunk(t), function (t) {\n              return Se((e.parsers.tiff = new n(t, e.options, e.file)).extractThumbnail(), function (t) {\n                return e.file.close && e.file.close(), t;\n              });\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }]), e;\n  }();\n\n  function Be(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n\n  function Ce(e) {\n    return function () {\n      for (var t = [], n = 0; n < arguments.length; n++) {\n        t[n] = arguments[n];\n      }\n\n      try {\n        return Promise.resolve(e.apply(this, t));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n  }\n\n  var je = Ce(function (e) {\n    var t = new xe(Ae);\n    return Be(t.read(e), function () {\n      return Be(t.parse(), function (e) {\n        if (e && e.ifd0) return e.ifd0[274];\n      });\n    });\n  }),\n      _e = Ce(function (e) {\n    var t = new xe(we);\n    return Be(t.read(e), function () {\n      return Be(t.parse(), function (e) {\n        if (e && e.gps) {\n          var t = e.gps;\n          return {\n            latitude: t.latitude,\n            longitude: t.longitude\n          };\n        }\n      });\n    });\n  }),\n      Ve = Ce(function (e) {\n    return Be(this.thumbnail(e), function (e) {\n      if (void 0 !== e) {\n        var t = new Blob([e]);\n        return URL.createObjectURL(t);\n      }\n    });\n  }),\n      Te = Ce(function (e) {\n    var t = new xe(Oe);\n    return Be(t.read(e), function () {\n      return Be(t.extractThumbnail(), function (e) {\n        return e && _ ? C.from(e) : e;\n      });\n    });\n  }),\n      Ie = Ce(function (e, t) {\n    var n = new xe(t);\n    return Be(n.read(e), function () {\n      return n.parse();\n    });\n  }),\n      Le = Object.freeze({\n    __proto__: null,\n    orientation: je,\n    gps: _e,\n    thumbnailUrl: Ve,\n    thumbnail: Te,\n    parse: Ie,\n    Exifr: xe,\n    fileParsers: N,\n    segmentParsers: M,\n    fileReaders: W,\n    tagKeys: te,\n    tagValues: ne,\n    tagRevivers: re,\n    createDictionary: $,\n    extendDictionary: ee,\n    fetchUrlAsArrayBuffer: J,\n    readBlobAsArrayBuffer: G,\n    chunkedProps: ie,\n    otherSegments: se,\n    segments: ae,\n    tiffBlocks: ue,\n    segmentsAndBlocks: oe,\n    tiffExtractables: fe,\n    inheritables: he,\n    allFormatters: ce,\n    Options: ye,\n    disableAllOptions: be,\n    gpsOnlyOptions: we,\n    orientationOnlyOptions: Ae,\n    thumbnailOnlyOptions: Oe\n  });\n\n  function ze() {}\n\n  var Fe = function (e) {\n    function n() {\n      var e, r;\n      t(this, n);\n\n      for (var s = arguments.length, u = new Array(s), o = 0; o < s; o++) {\n        u[o] = arguments[o];\n      }\n\n      return i(c(r = l(this, (e = a(n)).call.apply(e, [this].concat(u)))), \"ranges\", new Ee()), 0 !== r.byteLength && r.ranges.add(0, r.byteLength), r;\n    }\n\n    return s(n, e), r(n, [{\n      key: \"_tryExtend\",\n      value: function value(e, t, n) {\n        if (0 === e && 0 === this.byteLength && n) {\n          var r = new DataView(n.buffer || n, n.byteOffset, n.byteLength);\n\n          this._swapDataView(r);\n        } else {\n          var i = e + t;\n\n          if (i > this.byteLength) {\n            var s = this._extend(i).dataView;\n\n            this._swapDataView(s);\n          }\n        }\n      }\n    }, {\n      key: \"_extend\",\n      value: function value(e) {\n        var t;\n        t = _ ? C.allocUnsafe(e) : new Uint8Array(e);\n        var n = new DataView(t.buffer, t.byteOffset, t.byteLength);\n        return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), {\n          uintView: t,\n          dataView: n\n        };\n      }\n    }, {\n      key: \"subarray\",\n      value: function value(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        return t = t || this._lengthToEnd(e), r && this._tryExtend(e, t), this.ranges.add(e, t), d(a(n.prototype), \"subarray\", this).call(this, e, t);\n      }\n    }, {\n      key: \"set\",\n      value: function value(e, t) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n        r && this._tryExtend(t, e.byteLength, e);\n        var i = d(a(n.prototype), \"set\", this).call(this, e, t);\n        return this.ranges.add(t, i.byteLength), i;\n      }\n    }, {\n      key: \"ensureChunk\",\n      value: function value(e, t) {\n        try {\n          if (!this.chunked) return;\n          if (this.ranges.available(e, t)) return;\n          return function (e, t) {\n            if (!t) return e && e.then ? e.then(ze) : Promise.resolve();\n          }(this.readChunk(e, t));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"available\",\n      value: function value(e, t) {\n        return this.ranges.available(e, t);\n      }\n    }]), n;\n  }(E),\n      Ee = function () {\n    function e() {\n      t(this, e), i(this, \"list\", []);\n    }\n\n    return r(e, [{\n      key: \"add\",\n      value: function value(e, t) {\n        var n = e + t,\n            r = this.list.filter(function (t) {\n          return De(e, t.offset, n) || De(e, t.end, n);\n        });\n\n        if (r.length > 0) {\n          e = Math.min.apply(Math, [e].concat(r.map(function (e) {\n            return e.offset;\n          }))), t = (n = Math.max.apply(Math, [n].concat(r.map(function (e) {\n            return e.end;\n          })))) - e;\n          var i = r.shift();\n          i.offset = e, i.length = t, i.end = n, this.list = this.list.filter(function (e) {\n            return !r.includes(e);\n          });\n        } else this.list.push({\n          offset: e,\n          length: t,\n          end: n\n        });\n      }\n    }, {\n      key: \"available\",\n      value: function value(e, t) {\n        var n = e + t;\n        return this.list.some(function (t) {\n          return t.offset <= e && n <= t.end;\n        });\n      }\n    }, {\n      key: \"length\",\n      get: function get() {\n        return this.list.length;\n      }\n    }]), e;\n  }();\n\n  function De(e, t, n) {\n    return e <= t && t <= n;\n  }\n\n  function Re() {}\n\n  function Ne(e, t) {\n    if (!t) return e && e.then ? e.then(Re) : Promise.resolve();\n  }\n\n  function Me(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n\n  var We = function (e) {\n    function n() {\n      return t(this, n), l(this, a(n).apply(this, arguments));\n    }\n\n    return s(n, e), r(n, [{\n      key: \"readWhole\",\n      value: function value() {\n        try {\n          var e = this;\n          return e.chunked = !1, Me(G(e.input), function (t) {\n            e._swapArrayBuffer(t);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readChunked\",\n      value: function value() {\n        return this.chunked = !0, this.size = this.input.size, d(a(n.prototype), \"readChunked\", this).call(this);\n      }\n    }, {\n      key: \"_readChunk\",\n      value: function value(e, t) {\n        try {\n          var n = this,\n              r = t ? e + t : void 0,\n              i = n.input.slice(e, r);\n          return Me(G(i), function (t) {\n            return n.set(t, e, !0);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }]), n;\n  }(function (e) {\n    function n(e, r) {\n      var s;\n      return t(this, n), i(c(s = l(this, a(n).call(this, 0))), \"chunksRead\", 0), s.input = e, s.options = r, s;\n    }\n\n    return s(n, e), r(n, [{\n      key: \"readWhole\",\n      value: function value() {\n        try {\n          return this.chunked = !1, Ne(this.readChunk(this.nextChunkOffset));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readChunked\",\n      value: function value() {\n        try {\n          return this.chunked = !0, Ne(this.readChunk(0, this.options.firstChunkSize));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readNextChunk\",\n      value: function value(e) {\n        try {\n          if (void 0 === e && (e = this.nextChunkOffset), this.fullyRead) return this.chunksRead++, !1;\n          var t = this.options.chunkSize;\n          return n = this.readChunk(e, t), r = function r(e) {\n            return !!e && e.byteLength === t;\n          }, i ? r ? r(n) : n : (n && n.then || (n = Promise.resolve(n)), r ? n.then(r) : n);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n\n        var n, r, i;\n      }\n    }, {\n      key: \"readChunk\",\n      value: function value(e, t) {\n        try {\n          if (this.chunksRead++, 0 === (t = this.safeWrapAddress(e, t))) return;\n          return this._readChunk(e, t);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"safeWrapAddress\",\n      value: function value(e, t) {\n        return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;\n      }\n    }, {\n      key: \"read\",\n      value: function value() {\n        return this.options.chunked ? this.readChunked() : this.readWhole();\n      }\n    }, {\n      key: \"close\",\n      value: function value() {}\n    }, {\n      key: \"nextChunkOffset\",\n      get: function get() {\n        if (0 !== this.ranges.list.length) return this.ranges.list[0].length;\n      }\n    }, {\n      key: \"canReadNextChunk\",\n      get: function get() {\n        return this.chunksRead < this.options.chunkLimit;\n      }\n    }, {\n      key: \"fullyRead\",\n      get: function get() {\n        return void 0 !== this.size && this.nextChunkOffset === this.size;\n      }\n    }]), n;\n  }(Fe));\n\n  W.set(\"blob\", We);\n\n  var Ke = function () {\n    function e(n, r, s) {\n      var a,\n          u = this;\n      t(this, e), i(this, \"ensureSegmentChunk\", (a = function a(e) {\n        var t,\n            n,\n            r,\n            i = e.start,\n            s = e.size || 65536;\n        return t = function t() {\n          if (u.file.chunked) return function () {\n            if (!u.file.available(i, s)) return function (e, t) {\n              try {\n                var n = e();\n              } catch (e) {\n                return t(e);\n              }\n\n              return n && n.then ? n.then(void 0, t) : n;\n            }(function () {\n              return t = u.file.readChunk(i, s), n = function n(t) {\n                e.chunk = t;\n              }, r ? n ? n(t) : t : (t && t.then || (t = Promise.resolve(t)), n ? t.then(n) : t);\n              var t, n, r;\n            }, function (t) {\n              throw I(\"Couldn't read segment: \".concat(JSON.stringify(e), \". \").concat(t.message));\n            });\n            e.chunk = u.file.subarray(i, s);\n          }();\n          if (u.file.byteLength > i + s) e.chunk = u.file.subarray(i, s);else {\n            if (void 0 !== e.size) throw I(\"Segment unreachable: \" + JSON.stringify(e));\n            e.chunk = u.file.subarray(i);\n          }\n        }, n = function n(t) {\n          return e.chunk;\n        }, (r = t()) && r.then ? r.then(n) : n(r);\n      }, function () {\n        for (var e = [], t = 0; t < arguments.length; t++) {\n          e[t] = arguments[t];\n        }\n\n        try {\n          return Promise.resolve(a.apply(this, e));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      })), this.extendOptions && this.extendOptions(n), this.options = n, this.file = r, this.parsers = s;\n    }\n\n    return r(e, [{\n      key: \"createParser\",\n      value: function value(e, t) {\n        var n = new (M.get(e))(t, this.options, this.file);\n        return this.parsers[e] = n;\n      }\n    }]), e;\n  }(),\n      He = function () {\n    function e(n) {\n      var r = this,\n          s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          a = arguments.length > 2 ? arguments[2] : void 0;\n      t(this, e), i(this, \"errors\", []), i(this, \"raw\", O()), i(this, \"handleError\", function (e) {\n        if (!r.options.silentErrors) throw e;\n        r.errors.push(e.message);\n      }), this.chunk = this.normalizeInput(n), this.file = a, this.type = this.constructor.type, this.globalOptions = this.options = s, this.localOptions = s[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;\n    }\n\n    return r(e, [{\n      key: \"normalizeInput\",\n      value: function value(e) {\n        return e instanceof E ? e : new E(e);\n      }\n    }], [{\n      key: \"findPosition\",\n      value: function value(e, t) {\n        var n = e.getUint16(t + 2) + 2,\n            r = \"function\" == typeof this.headerLength ? this.headerLength(e, t, n) : this.headerLength,\n            i = t + r,\n            s = n - r;\n        return {\n          offset: t,\n          length: n,\n          headerLength: r,\n          start: i,\n          size: s,\n          end: i + s\n        };\n      }\n    }, {\n      key: \"parse\",\n      value: function value(e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            n = new ye(i({}, this.type, t)),\n            r = new this(e, n);\n        return r.parse();\n      }\n    }]), r(e, [{\n      key: \"translate\",\n      value: function value() {\n        this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));\n      }\n    }, {\n      key: \"translateBlock\",\n      value: function value(e, t) {\n        var n = re.get(t),\n            r = ne.get(t),\n            i = te.get(t),\n            s = this.options[t],\n            a = s.reviveValues && !!n,\n            u = s.translateValues && !!r,\n            o = s.translateKeys && !!i,\n            f = {},\n            h = e;\n        Array.isArray(h) || (\"function\" == typeof h.entries && (h = h.entries()), h = k(h));\n\n        for (var c = 0; c < h.length; c++) {\n          var l = h[c],\n              d = l[0],\n              v = l[1];\n          a && n.has(d) ? v = n.get(d)(v) : u && r.has(d) && (v = this.translateValue(v, r.get(d))), o && i.has(d) && (d = i.get(d) || d), f[d] = v;\n        }\n\n        return f;\n      }\n    }, {\n      key: \"translateValue\",\n      value: function value(e, t) {\n        return t[e] || e;\n      }\n    }, {\n      key: \"assignToOutput\",\n      value: function value(e, t) {\n        this.assignObjectToOutput(e, this.constructor.type, t);\n      }\n    }, {\n      key: \"assignObjectToOutput\",\n      value: function value(e, t, n) {\n        if (this.globalOptions.mergeOutput) return y(e, n);\n        e[t] ? y(e[t], n) : e[t] = n;\n      }\n    }, {\n      key: \"output\",\n      get: function get() {\n        return this.translated ? this.translated : this.raw ? g(this.raw) : void 0;\n      }\n    }]), e;\n  }();\n\n  function Ge(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n\n  i(He, \"headerLength\", 4), i(He, \"type\", void 0), i(He, \"multiSegment\", !1), i(He, \"canHandle\", function () {\n    return !1;\n  });\n\n  function Je() {}\n\n  function Xe(e, t) {\n    if (!t) return e && e.then ? e.then(Je) : Promise.resolve();\n  }\n\n  function qe(e) {\n    var t = e();\n    if (t && t.then) return t.then(Je);\n  }\n\n  function Qe(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n\n  function Ye(e, t, n) {\n    if (!e.s) {\n      if (n instanceof Ze) {\n        if (!n.s) return void (n.o = Ye.bind(null, e, t));\n        1 & t && (t = n.s), n = n.v;\n      }\n\n      if (n && n.then) return void n.then(Ye.bind(null, e, t), Ye.bind(null, e, 2));\n      e.s = t, e.v = n;\n      var r = e.o;\n      r && r(e);\n    }\n  }\n\n  var Ze = function () {\n    function e() {}\n\n    return e.prototype.then = function (t, n) {\n      var r = new e(),\n          i = this.s;\n\n      if (i) {\n        var s = 1 & i ? t : n;\n\n        if (s) {\n          try {\n            Ye(r, 1, s(this.v));\n          } catch (e) {\n            Ye(r, 2, e);\n          }\n\n          return r;\n        }\n\n        return this;\n      }\n\n      return this.o = function (e) {\n        try {\n          var i = e.v;\n          1 & e.s ? Ye(r, 1, t ? t(i) : i) : n ? Ye(r, 1, n(i)) : Ye(r, 2, i);\n        } catch (e) {\n          Ye(r, 2, e);\n        }\n      }, r;\n    }, e;\n  }();\n\n  function $e(e) {\n    return e instanceof Ze && 1 & e.s;\n  }\n\n  function et(e, t, n) {\n    for (var r;;) {\n      var i = e();\n      if ($e(i) && (i = i.v), !i) return s;\n\n      if (i.then) {\n        r = 0;\n        break;\n      }\n\n      var s = n();\n\n      if (s && s.then) {\n        if (!$e(s)) {\n          r = 1;\n          break;\n        }\n\n        s = s.s;\n      }\n\n      if (t) {\n        var a = t();\n\n        if (a && a.then && !$e(a)) {\n          r = 2;\n          break;\n        }\n      }\n    }\n\n    var u = new Ze(),\n        o = Ye.bind(null, u, 2);\n    return (0 === r ? i.then(h) : 1 === r ? s.then(f) : a.then(c)).then(void 0, o), u;\n\n    function f(r) {\n      s = r;\n\n      do {\n        if (t && (a = t()) && a.then && !$e(a)) return void a.then(c).then(void 0, o);\n        if (!(i = e()) || $e(i) && !i.v) return void Ye(u, 1, s);\n        if (i.then) return void i.then(h).then(void 0, o);\n        $e(s = n()) && (s = s.v);\n      } while (!s || !s.then);\n\n      s.then(f).then(void 0, o);\n    }\n\n    function h(e) {\n      e ? (s = n()) && s.then ? s.then(f).then(void 0, o) : f(s) : Ye(u, 1, s);\n    }\n\n    function c() {\n      (i = e()) ? i.then ? i.then(h).then(void 0, o) : h(i) : Ye(u, 1, s);\n    }\n  }\n\n  function tt(e) {\n    return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;\n  }\n\n  function nt(e) {\n    return e >= 224 && e <= 239;\n  }\n\n  function rt(e, t) {\n    var n = M;\n    Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n    for (var r = 0; r < n.length; r++) {\n      var i = n[r],\n          s = i[0];\n      if (i[1].canHandle(e, t)) return s;\n    }\n  }\n\n  var it = function (e) {\n    function n() {\n      var e, r;\n      t(this, n);\n\n      for (var s = arguments.length, u = new Array(s), o = 0; o < s; o++) {\n        u[o] = arguments[o];\n      }\n\n      return i(c(r = l(this, (e = a(n)).call.apply(e, [this].concat(u)))), \"appSegments\", []), i(c(r), \"jpegSegments\", []), i(c(r), \"unknownSegments\", []), r;\n    }\n\n    return s(n, e), r(n, [{\n      key: \"parse\",\n      value: function value() {\n        try {\n          var e = this;\n          return Ge(e.findAppSegments(), function () {\n            return Ge(e.readSegments(), function () {\n              e.mergeMultiSegments(), e.createParsers();\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readSegments\",\n      value: function value() {\n        try {\n          var e = this.appSegments.map(this.ensureSegmentChunk);\n          return Xe(Promise.all(e));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"setupSegmentFinderArgs\",\n      value: function value(e) {\n        var t = this;\n        !0 === e ? (this.findAll = !0, this.wanted = A(M.keyList())) : (e = void 0 === e ? M.keyList().filter(function (e) {\n          return t.options[e].enabled;\n        }) : e.filter(function (e) {\n          return t.options[e].enabled && M.has(e);\n        }), this.findAll = !1, this.remaining = A(e), this.wanted = A(e)), this.unfinishedMultiSegment = !1;\n      }\n    }, {\n      key: \"findAppSegments\",\n      value: function value() {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n            t = arguments.length > 1 ? arguments[1] : void 0;\n\n        try {\n          var n = this;\n          n.setupSegmentFinderArgs(t);\n          var r = n.file,\n              i = n.findAll,\n              s = n.wanted,\n              a = n.remaining;\n          return Qe(function () {\n            if (!i && n.file.chunked) return i = k(s).some(function (e) {\n              var t = M.get(e),\n                  r = n.options[e];\n              return t.multiSegment && r.multiSegment;\n            }), qe(function () {\n              if (i) return Xe(n.file.readWhole());\n            });\n          }, function () {\n            var t = !1;\n            if (e = n._findAppSegments(e, r.byteLength, i, s, a), !n.options.onlyTiff) return function () {\n              if (r.chunked) {\n                var i = !1;\n                return et(function () {\n                  return !t && a.size > 0 && !i && (!!r.canReadNextChunk || !!n.unfinishedMultiSegment);\n                }, void 0, function () {\n                  var s = r.nextChunkOffset,\n                      a = n.appSegments.some(function (e) {\n                    return !n.file.available(e.offset || e.start, e.length || e.size);\n                  });\n                  return Qe(function () {\n                    return e > s && !a ? Ge(r.readNextChunk(e), function (e) {\n                      i = !e;\n                    }) : Ge(r.readNextChunk(s), function (e) {\n                      i = !e;\n                    });\n                  }, function () {\n                    void 0 === (e = n._findAppSegments(e, r.byteLength)) && (t = !0);\n                  });\n                });\n              }\n            }();\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"_findAppSegments\",\n      value: function value(e, t) {\n        for (var n, r, i, s, a, u, o = this.file, f = this.findAll, h = this.wanted, c = this.remaining, l = this.options; e < t; e++) {\n          if (255 === o.getUint8(e)) if (nt(n = o.getUint8(e + 1))) {\n            if (r = o.getUint16(e + 2), (i = rt(o, e)) && h.has(i) && (a = (s = M.get(i)).findPosition(o, e), u = l[i], a.type = i, this.appSegments.push(a), !f && (s.multiSegment && u.multiSegment ? (this.unfinishedMultiSegment = a.chunkNumber < a.chunkCount, this.unfinishedMultiSegment || c.delete(i)) : c.delete(i), 0 === c.size))) break;\n            l.recordUnknownSegments && ((a = He.findPosition(o, e)).marker = n, this.unknownSegments.push(a)), e += r + 1;\n          } else if (tt(n)) {\n            if (r = o.getUint16(e + 2), 218 === n && !1 !== l.stopAfterSos) return;\n            l.recordJpegSegments && this.jpegSegments.push({\n              offset: e,\n              length: r,\n              marker: n\n            }), e += r + 1;\n          }\n        }\n\n        return e;\n      }\n    }, {\n      key: \"mergeMultiSegments\",\n      value: function value() {\n        var e = this;\n\n        if (this.appSegments.some(function (e) {\n          return e.multiSegment;\n        })) {\n          var t = function (e, t) {\n            for (var n, r, i, s = O(), a = 0; a < e.length; a++) {\n              n = e[a], r = n[t], s.has(r) ? i = s.get(r) : s.set(r, i = []), i.push(n);\n            }\n\n            return k(s);\n          }(this.appSegments, \"type\");\n\n          this.mergedAppSegments = t.map(function (t) {\n            var n = t[0],\n                r = t[1],\n                i = M.get(n, e.options);\n            return i.handleMultiSegments ? {\n              type: n,\n              chunk: i.handleMultiSegments(r)\n            } : r[0];\n          });\n        }\n      }\n    }, {\n      key: \"createParsers\",\n      value: function value() {\n        try {\n          var e = this.mergedAppSegments || this.appSegments;\n          Array.isArray(e) || (\"function\" == typeof e.entries && (e = e.entries()), e = k(e));\n\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t],\n                r = n.type,\n                i = n.chunk;\n\n            if (this.options[r].enabled) {\n              var s = this.parsers[r];\n              if (s && s.append) ;else if (!s) {\n                var a = new (M.get(r, this.options))(i, this.options, this.file);\n                this.parsers[r] = a;\n              }\n            }\n          }\n\n          return Ge();\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"getSegment\",\n      value: function value(e) {\n        return this.appSegments.find(function (t) {\n          return t.type === e;\n        });\n      }\n    }, {\n      key: \"getOrFindSegment\",\n      value: function value(e) {\n        try {\n          var t = this,\n              n = t.getSegment(e);\n          return Qe(function () {\n            if (void 0 === n) return Ge(t.findAppSegments(0, [e]), function () {\n              n = t.getSegment(e);\n            });\n          }, function () {\n            return n;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }]), n;\n  }(Ke);\n\n  function st() {}\n\n  N.set(\"jpeg\", it);\n\n  function at(e, t) {\n    if (!t) return e && e.then ? e.then(st) : Promise.resolve();\n  }\n\n  function ut(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n\n  var ot = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];\n\n  var ft = function (e) {\n    function n() {\n      return t(this, n), l(this, a(n).apply(this, arguments));\n    }\n\n    return s(n, e), r(n, [{\n      key: \"parse\",\n      value: function value() {\n        try {\n          var e = this;\n          return e.parseHeader(), ut(function () {\n            if (e.options.ifd0.enabled) return at(e.parseIfd0Block());\n          }, function () {\n            return ut(function () {\n              if (e.options.exif.enabled) return at(e.saveParseBlock(\"parseExifBlock\"));\n            }, function () {\n              return ut(function () {\n                if (e.options.gps.enabled) return at(e.saveParseBlock(\"parseGpsBlock\"));\n              }, function () {\n                return ut(function () {\n                  if (e.options.interop.enabled) return at(e.saveParseBlock(\"parseInteropBlock\"));\n                }, function () {\n                  return ut(function () {\n                    if (e.options.ifd1.enabled) return at(e.saveParseBlock(\"parseThumbnailBlock\"));\n                  }, function () {\n                    return e.createOutput();\n                  });\n                });\n              });\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"saveParseBlock\",\n      value: function value(e) {\n        try {\n          var t = this;\n          return function (e, t) {\n            try {\n              var n = e();\n            } catch (e) {\n              return t(e);\n            }\n\n            return n && n.then ? n.then(void 0, t) : n;\n          }(function () {\n            return n = t[e](), i ? r ? r(n) : n : (n && n.then || (n = Promise.resolve(n)), r ? n.then(r) : n);\n            var n, r, i;\n          }, function (e) {\n            t.handleError(e);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"findIfd0Offset\",\n      value: function value() {\n        void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));\n      }\n    }, {\n      key: \"findIfd1Offset\",\n      value: function value() {\n        if (void 0 === this.ifd1Offset) {\n          this.findIfd0Offset();\n          var e = this.chunk.getUint16(this.ifd0Offset),\n              t = this.ifd0Offset + 2 + 12 * e;\n          this.ifd1Offset = this.chunk.getUint32(t);\n        }\n      }\n    }, {\n      key: \"parseBlock\",\n      value: function value(e, t) {\n        var n = O();\n        return this[t] = n, this.parseTags(e, t, n), n;\n      }\n    }, {\n      key: \"parseIfd0Block\",\n      value: function value() {\n        try {\n          var e = this;\n          if (e.ifd0) return;\n          if (e.findIfd0Offset(), e.ifd0Offset < 8) throw I(\"Invalid EXIF data: IFD0 offset should be less than 8\");\n          if (!e.file.chunked && e.ifd0Offset > e.file.byteLength) throw I(\"IFD0 offset points to outside of file.\\nthis.ifd0Offset: \".concat(e.ifd0Offset, \", file.byteLength: \").concat(e.file.byteLength));\n          return ut(function () {\n            if (e.file.isTiff) return at(e.file.ensureChunk(e.ifd0Offset, L(e.options)));\n          }, function () {\n            var t = e.parseBlock(e.ifd0Offset, \"ifd0\");\n            if (0 !== t.size) return e.exifOffset = t.get(34665), e.interopOffset = t.get(40965), e.gpsOffset = t.get(34853), e.xmp = t.get(700), e.iptc = t.get(33723), e.icc = t.get(34675), e.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"ensureBlockChunk\",\n      value: function value(e, t) {\n        try {\n          var n = this;\n          return ut(function () {\n            if (n.file.isTiff) return at(n.file.ensureChunk(e, t));\n          }, function () {\n            e > n.chunk.byteLength && (n.chunk = E.from(n.file, n.le));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseExifBlock\",\n      value: function value() {\n        try {\n          var e = this;\n          if (e.exif) return;\n          return ut(function () {\n            if (!e.ifd0) return at(e.parseIfd0Block());\n          }, function () {\n            if (void 0 !== e.exifOffset) return ut(function () {\n              if (e.file.isTiff) return at(e.file.ensureChunk(e.exifOffset, L(e.options)));\n            }, function () {\n              var t = e.parseBlock(e.exifOffset, \"exif\");\n              return e.interopOffset || (e.interopOffset = t.get(40965)), e.makerNote = t.get(37500), e.userComment = t.get(37510), e.options.sanitize && (t.delete(40965), t.delete(37500), t.delete(37510)), e.unpack(t, 41728), e.unpack(t, 41729), t;\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"unpack\",\n      value: function value(e, t) {\n        var n = e.get(t);\n        n && 1 === n.length && e.set(t, n[0]);\n      }\n    }, {\n      key: \"parseGpsBlock\",\n      value: function value() {\n        try {\n          var e = this;\n          if (e.gps) return;\n          return ut(function () {\n            if (!e.ifd0) return at(e.parseIfd0Block());\n          }, function () {\n            if (void 0 !== e.gpsOffset) {\n              var t = e.parseBlock(e.gpsOffset, \"gps\");\n              return t && t.has(2) && t.has(4) && (t.set(\"latitude\", ht.apply(void 0, t.get(2).concat([t.get(1)]))), t.set(\"longitude\", ht.apply(void 0, t.get(4).concat([t.get(3)])))), t;\n            }\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseInteropBlock\",\n      value: function value() {\n        try {\n          var e = this;\n          if (e.interop) return;\n          return ut(function () {\n            if (!e.ifd0) return at(e.parseIfd0Block());\n          }, function () {\n            return ut(function () {\n              if (void 0 === e.interopOffset && !e.exif) return at(e.parseExifBlock());\n            }, function () {\n              if (void 0 !== e.interopOffset) return e.parseBlock(e.interopOffset, \"interop\");\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseThumbnailBlock\",\n      value: function value() {\n        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n        try {\n          var t = this;\n          if (t.ifd1 || t.ifd1Parsed) return;\n          if (t.options.mergeOutput && !e) return;\n          return t.findIfd1Offset(), t.ifd1Offset > 0 && (t.parseBlock(t.ifd1Offset, \"ifd1\"), t.ifd1Parsed = !0), t.ifd1;\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"extractThumbnail\",\n      value: function value() {\n        try {\n          var e = this;\n          return e.headerParsed || e.parseHeader(), ut(function () {\n            if (!e.ifd1Parsed) return at(e.parseThumbnailBlock(!0));\n          }, function () {\n            if (void 0 !== e.ifd1) {\n              var t = e.ifd1.get(513),\n                  n = e.ifd1.get(514);\n              return e.chunk.getUint8Array(t, n);\n            }\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"createOutput\",\n      value: function value() {\n        var e,\n            t,\n            n,\n            r = {},\n            i = ue;\n        Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = k(i));\n\n        for (var s = 0; s < i.length; s++) {\n          if (!T(e = this[t = i[s]])) if (n = this.canTranslate ? this.translateBlock(e, t) : g(e), this.options.mergeOutput) {\n            if (\"ifd1\" === t) continue;\n            y(r, n);\n          } else r[t] = n;\n        }\n\n        return this.makerNote && (r.makerNote = this.makerNote), this.userComment && (r.userComment = this.userComment), r;\n      }\n    }, {\n      key: \"assignToOutput\",\n      value: function value(e, t) {\n        if (this.globalOptions.mergeOutput) y(e, t);else {\n          var n = p(t);\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = k(n));\n\n          for (var r = 0; r < n.length; r++) {\n            var i = n[r],\n                s = i[0],\n                a = i[1];\n            this.assignObjectToOutput(e, s, a);\n          }\n        }\n      }\n    }, {\n      key: \"image\",\n      get: function get() {\n        return this.ifd0;\n      }\n    }, {\n      key: \"thumbnail\",\n      get: function get() {\n        return this.ifd1;\n      }\n    }], [{\n      key: \"canHandle\",\n      value: function value(e, t) {\n        return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);\n      }\n    }]), n;\n  }(function (e) {\n    function n() {\n      return t(this, n), l(this, a(n).apply(this, arguments));\n    }\n\n    return s(n, e), r(n, [{\n      key: \"parseHeader\",\n      value: function value() {\n        var e = this.chunk.getUint16();\n        if (18761 === e) this.le = !0;else {\n          if (19789 !== e) throw I(\"Invalid EXIF data: expected byte order marker (0x4949 or 0x4D4D).\");\n          this.le = !1;\n        }\n        if (this.chunk.le = this.le, 42 !== this.chunk.getUint16(2)) throw I(\"Invalid EXIF data: expected 0x002A.\");\n        this.headerParsed = !0;\n      }\n    }, {\n      key: \"parseTags\",\n      value: function value(e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : O(),\n            r = this.options[t],\n            i = r.pick,\n            s = r.skip,\n            a = (i = A(i)).size > 0,\n            u = 0 === s.size,\n            o = this.chunk.getUint16(e);\n        e += 2;\n\n        for (var f = 0; f < o; f++) {\n          var h = this.chunk.getUint16(e);\n\n          if (a) {\n            if (i.has(h) && (n.set(h, this.parseTag(e, h, t)), i.delete(h), 0 === i.size)) break;\n          } else !u && s.has(h) || n.set(h, this.parseTag(e, h, t));\n\n          e += 12;\n        }\n\n        return n;\n      }\n    }, {\n      key: \"parseTag\",\n      value: function value(e, t, n) {\n        var r,\n            i = this.chunk.getUint16(e + 2),\n            s = this.chunk.getUint32(e + 4),\n            a = ot[i];\n        if (a * s <= 4 ? e += 8 : e = this.chunk.getUint32(e + 8), i < 1 || i > 13) throw I(\"Invalid TIFF value type. block: \".concat(n.toUpperCase(), \", tag: \").concat(t.toString(16), \", type: \").concat(i, \", offset \").concat(e));\n        if (e > this.chunk.byteLength) throw I(\"Invalid TIFF value offset. block: \".concat(n.toUpperCase(), \", tag: \").concat(t.toString(16), \", type: \").concat(i, \", offset \").concat(e, \" is outside of chunk size \").concat(this.chunk.byteLength));\n        if (1 === i) return this.chunk.getUint8Array(e, s);\n        if (2 === i) return \"\" === (r = function (e) {\n          for (; e.endsWith(\"\\0\");) {\n            e = e.slice(0, -1);\n          }\n\n          return e;\n        }(r = this.chunk.getString(e, s)).trim()) ? void 0 : r;\n        if (7 === i) return this.chunk.getUint8Array(e, s);\n        if (1 === s) return this.parseTagValue(i, e);\n\n        for (var u = new (function (e) {\n          switch (e) {\n            case 1:\n              return Uint8Array;\n\n            case 3:\n              return Uint16Array;\n\n            case 4:\n              return Uint32Array;\n\n            case 5:\n              return Array;\n\n            case 6:\n              return Int8Array;\n\n            case 8:\n              return Int16Array;\n\n            case 9:\n              return Int32Array;\n\n            case 10:\n              return Array;\n\n            case 11:\n              return Float32Array;\n\n            case 12:\n              return Float64Array;\n\n            default:\n              return Array;\n          }\n        }(i))(s), o = a, f = 0; f < s; f++) {\n          u[f] = this.parseTagValue(i, e), e += o;\n        }\n\n        return u;\n      }\n    }, {\n      key: \"parseTagValue\",\n      value: function value(e, t) {\n        switch (e) {\n          case 1:\n            return this.chunk.getUint8(t);\n\n          case 3:\n            return this.chunk.getUint16(t);\n\n          case 4:\n            return this.chunk.getUint32(t);\n\n          case 5:\n            return this.chunk.getUint32(t) / this.chunk.getUint32(t + 4);\n\n          case 6:\n            return this.chunk.getInt8(t);\n\n          case 8:\n            return this.chunk.getInt16(t);\n\n          case 9:\n            return this.chunk.getInt32(t);\n\n          case 10:\n            return this.chunk.getInt32(t) / this.chunk.getInt32(t + 4);\n\n          case 11:\n            return this.chunk.getFloat(t);\n\n          case 12:\n            return this.chunk.getDouble(t);\n\n          case 13:\n            return this.chunk.getUint32(t);\n\n          default:\n            throw I(\"Invalid tiff type \".concat(e));\n        }\n      }\n    }]), n;\n  }(He));\n\n  function ht(e, t, n, r) {\n    var i = e + t / 60 + n / 3600;\n    return \"S\" !== r && \"W\" !== r || (i *= -1), i;\n  }\n\n  i(ft, \"type\", \"tiff\"), i(ft, \"headerLength\", 10), M.set(\"tiff\", ft), e.Exifr = xe, e.Options = ye, e.allFormatters = ce, e.chunkedProps = ie, e.createDictionary = $, e.default = Le, e.disableAllOptions = be, e.extendDictionary = ee, e.fetchUrlAsArrayBuffer = J, e.fileParsers = N, e.fileReaders = W, e.gps = _e, e.gpsOnlyOptions = we, e.inheritables = he, e.orientation = je, e.orientationOnlyOptions = Ae, e.otherSegments = se, e.parse = Ie, e.readBlobAsArrayBuffer = G, e.segmentParsers = M, e.segments = ae, e.segmentsAndBlocks = oe, e.tagKeys = te, e.tagRevivers = re, e.tagValues = ne, e.thumbnail = Te, e.thumbnailOnlyOptions = Oe, e.thumbnailUrl = Ve, e.tiffBlocks = ue, e.tiffExtractables = fe, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}