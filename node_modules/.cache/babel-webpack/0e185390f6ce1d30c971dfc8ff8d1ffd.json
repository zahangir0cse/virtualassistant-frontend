{"ast":null,"code":"import _classCallCheck from \"/Users/zahangiralam/Desktop/Projects/Mozahid Bhai/virtualassistant-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/zahangiralam/Desktop/Projects/Mozahid Bhai/virtualassistant-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { GoogleMapsAPIWrapper } from '@agm/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@agm/core';\n\nvar AgmDirection = /*#__PURE__*/function () {\n  /**\n   * @param {?} gmapsApi\n   */\n  function AgmDirection(gmapsApi) {\n    _classCallCheck(this, AgmDirection);\n\n    this.gmapsApi = gmapsApi; // Options\n\n    this.travelMode = 'DRIVING';\n    this.transitOptions = undefined;\n    this.drivingOptions = undefined;\n    this.waypoints = [];\n    this.optimizeWaypoints = true;\n    this.provideRouteAlternatives = false;\n    this.avoidHighways = false;\n    this.avoidTolls = false; // Remove or draw direction\n\n    this.visible = true; // Direction change event handler\n\n    this.onChange = new EventEmitter(); // Direction response for the new request\n\n    this.onResponse = new EventEmitter(); // Send a custom infowindow\n\n    this.sendInfoWindow = new EventEmitter(); // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)\n\n    this.status = new EventEmitter(); // Marker drag event handler\n\n    this.originDrag = new EventEmitter();\n    this.destinationDrag = new EventEmitter();\n    this.directionsService = undefined;\n    this.directionsDisplay = undefined;\n    this.waypointsMarker = []; // Use for visible flag\n\n    this.isFirstChange = true;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(AgmDirection, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      if (this.visible === true) {\n        this.directionDraw();\n      }\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(obj) {\n      /**\n       * When visible is false then remove the direction layer\n       */\n      if (!this.visible) {\n        try {\n          this.removeMarkers();\n          this.removeDirections();\n        } catch (e) {}\n      } else {\n        if (this.isFirstChange) {\n          /**\n           * When visible is false at the first time\n           */\n          if (typeof this.directionsDisplay === 'undefined') {\n            this.directionDraw();\n          }\n\n          this.isFirstChange = false;\n          return;\n        }\n        /**\n         * When renderOptions are not first change then reset the display\n         */\n\n\n        if (typeof obj.renderOptions !== 'undefined') {\n          if (obj.renderOptions.firstChange === false) {\n            this.removeMarkers();\n            this.removeDirections();\n          }\n        }\n\n        this.directionDraw();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.destroyMarkers();\n      this.removeDirections();\n    }\n    /**\n     * This event is fired when the user creating or updating this direction\n     * @return {?}\n     */\n\n  }, {\n    key: \"directionDraw\",\n    value: function directionDraw() {\n      var _this = this;\n\n      this.gmapsApi.getNativeMap().then(function (map) {\n        if (typeof _this.directionsDisplay === 'undefined') {\n          _this.directionsDisplay = new google.maps.DirectionsRenderer(_this.renderOptions);\n\n          _this.directionsDisplay.setMap(map);\n\n          _this.directionsDisplay.addListener('directions_changed', function () {\n            _this.onChange.emit(_this.directionsDisplay.getDirections());\n          });\n        }\n\n        if (typeof _this.directionsService === 'undefined') {\n          _this.directionsService = new google.maps.DirectionsService();\n        }\n\n        if (typeof _this.panel === 'undefined') {\n          _this.directionsDisplay.setPanel(null);\n        } else {\n          _this.directionsDisplay.setPanel(_this.panel);\n        } // Render exist direction\n\n\n        if (typeof _this.renderRoute === 'object' && _this.renderRoute !== null) {\n          _this.directionsDisplay.setDirections(_this.renderRoute);\n\n          _this.renderRoute = null; // or set undefined, ''\n        } else {\n          // Request new direction\n          _this.directionsService.route({\n            origin: _this.origin,\n            destination: _this.destination,\n            travelMode: _this.travelMode,\n            transitOptions: _this.transitOptions,\n            drivingOptions: _this.drivingOptions,\n            waypoints: _this.waypoints,\n            optimizeWaypoints: _this.optimizeWaypoints,\n            provideRouteAlternatives: _this.provideRouteAlternatives,\n            avoidHighways: _this.avoidHighways,\n            avoidTolls: _this.avoidTolls\n          }, function (response, status) {\n            _this.onResponse.emit(response); // Emit Query Status\n\n\n            _this.status.emit(status);\n            /**\n             * DirectionsStatus\n             * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus\n             */\n\n\n            switch (status) {\n              case 'OK':\n                _this.directionsDisplay.setDirections(response);\n                /**\n                 * Emit The DirectionsResult Object\n                 * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults\n                 */\n                // Custom Markers\n\n\n                if (typeof _this.markerOptions !== 'undefined') {\n                  _this.destroyMarkers(); // Set custom markers\n\n                  /** @type {?} */\n\n\n                  var _route = response.routes[0].legs[0];\n\n                  try {\n                    // Origin Marker\n                    if (typeof _this.markerOptions.origin !== 'undefined') {\n                      _this.markerOptions.origin.map = map;\n                      _this.markerOptions.origin.position = _route.start_location;\n                      _this.originMarker = _this.setMarker(map, _this.originMarker, _this.markerOptions.origin, _route.start_address);\n\n                      if (_this.markerOptions.origin.draggable) {\n                        _this.originMarker.addListener('dragend', function () {\n                          _this.origin = _this.originMarker.position;\n\n                          _this.directionDraw();\n\n                          _this.originDrag.emit(_this.origin);\n                        });\n                      }\n                    } // Destination Marker\n\n\n                    if (typeof _this.markerOptions.destination !== 'undefined') {\n                      _this.markerOptions.destination.map = map;\n                      _this.markerOptions.destination.position = _route.end_location;\n                      _this.destinationMarker = _this.setMarker(map, _this.destinationMarker, _this.markerOptions.destination, _route.end_address);\n\n                      if (_this.markerOptions.destination.draggable) {\n                        _this.destinationMarker.addListener('dragend', function () {\n                          _this.destination = _this.destinationMarker.position;\n\n                          _this.directionDraw();\n\n                          _this.destinationDrag.emit(_this.destination);\n                        });\n                      }\n                    } // Waypoints Marker\n\n\n                    if (typeof _this.markerOptions.waypoints !== 'undefined') {\n                      _this.waypoints.forEach(function (waypoint, index) {\n                        // If waypoints are not array then set all the same\n                        if (!Array.isArray(_this.markerOptions.waypoints)) {\n                          _this.markerOptions.waypoints.map = map;\n                          _this.markerOptions.waypoints.position = _route.via_waypoints[index];\n\n                          _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints, _route.via_waypoints[index]));\n                        } else {\n                          _this.markerOptions.waypoints[index].map = map;\n                          _this.markerOptions.waypoints[index].position = _route.via_waypoints[index];\n\n                          _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints[index], _route.via_waypoints[index]));\n                        }\n                      }); // End forEach\n\n                    }\n                  } catch (err) {\n                    console.error('MarkerOptions error.', err);\n                  }\n                }\n\n                break;\n\n              default:\n                // console.warn(status);\n                break;\n            } // End switch\n\n          });\n        }\n      });\n    }\n    /**\n     * Custom Origin and Destination Icon\n     * \\@memberof AgmDirection\n     * @param {?} map map\n     * @param {?} marker marker\n     * @param {?} markerOpts properties\n     * @param {?} content marker's infowindow content\n     * @return {?} new marker\n     */\n\n  }, {\n    key: \"setMarker\",\n    value: function setMarker(map, marker, markerOpts, content) {\n      var _this2 = this;\n\n      if (typeof this.infoWindow === 'undefined') {\n        this.infoWindow = new google.maps.InfoWindow({});\n        this.sendInfoWindow.emit(this.infoWindow);\n      }\n\n      marker = new google.maps.Marker(markerOpts); // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable\n\n      if (marker.clickable) {\n        marker.addListener('click', function () {\n          /** @type {?} */\n          var infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;\n\n          _this2.infoWindow.setContent(infowindoContent);\n\n          _this2.infoWindow.open(map, marker);\n        });\n      }\n\n      return marker;\n    }\n    /**\n     * This event is fired when remove markers\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeMarkers\",\n    value: function removeMarkers() {\n      if (typeof this.originMarker !== 'undefined') {\n        this.originMarker.setMap(null);\n      }\n\n      if (typeof this.destinationMarker !== 'undefined') {\n        this.destinationMarker.setMap(null);\n      }\n\n      this.waypointsMarker.forEach(function (w) {\n        if (typeof w !== 'undefined') {\n          w.setMap(null);\n        }\n      });\n    }\n    /**\n     * This event is fired when remove directions\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeDirections\",\n    value: function removeDirections() {\n      if (this.directionsDisplay !== undefined) {\n        this.directionsDisplay.setPanel(null);\n        this.directionsDisplay.setMap(null);\n        this.directionsDisplay = undefined;\n      }\n    }\n    /**\n     * This event is fired when destroy markers\n     * @return {?}\n     */\n\n  }, {\n    key: \"destroyMarkers\",\n    value: function destroyMarkers() {\n      // Remove origin markers\n      try {\n        if (typeof this.originMarker !== 'undefined') {\n          google.maps.event.clearListeners(this.originMarker, 'click');\n\n          if (this.markerOptions.origin.draggable) {\n            google.maps.event.clearListeners(this.originMarker, 'dragend');\n          }\n        }\n\n        if (typeof this.destinationMarker !== 'undefined') {\n          google.maps.event.clearListeners(this.destinationMarker, 'click');\n\n          if (this.markerOptions.origin.draggable) {\n            google.maps.event.clearListeners(this.destinationMarker, 'dragend');\n          }\n        }\n\n        this.waypointsMarker.forEach(function (w) {\n          if (typeof w !== 'undefined') {\n            google.maps.event.clearListeners(w, 'click');\n          }\n        });\n        this.removeMarkers();\n      } catch (err) {\n        console.error('Can not reset custom marker.', err);\n      }\n    }\n  }]);\n\n  return AgmDirection;\n}();\n\nAgmDirection.ɵfac = function AgmDirection_Factory(t) {\n  return new (t || AgmDirection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.GoogleMapsAPIWrapper));\n};\n\nAgmDirection.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: AgmDirection,\n  selectors: [[\"agm-direction\"]],\n  inputs: {\n    travelMode: \"travelMode\",\n    transitOptions: \"transitOptions\",\n    drivingOptions: \"drivingOptions\",\n    waypoints: \"waypoints\",\n    optimizeWaypoints: \"optimizeWaypoints\",\n    provideRouteAlternatives: \"provideRouteAlternatives\",\n    avoidHighways: \"avoidHighways\",\n    avoidTolls: \"avoidTolls\",\n    visible: \"visible\",\n    renderRoute: \"renderRoute\",\n    origin: \"origin\",\n    destination: \"destination\",\n    infoWindow: \"infoWindow\",\n    renderOptions: \"renderOptions\",\n    panel: \"panel\",\n    markerOptions: \"markerOptions\"\n  },\n  outputs: {\n    onChange: \"onChange\",\n    onResponse: \"onResponse\",\n    sendInfoWindow: \"sendInfoWindow\",\n    status: \"status\",\n    originDrag: \"originDrag\",\n    destinationDrag: \"destinationDrag\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nAgmDirection.ctorParameters = function () {\n  return [{\n    type: GoogleMapsAPIWrapper\n  }];\n};\n\nAgmDirection.propDecorators = {\n  origin: [{\n    type: Input\n  }],\n  destination: [{\n    type: Input\n  }],\n  travelMode: [{\n    type: Input\n  }],\n  transitOptions: [{\n    type: Input\n  }],\n  drivingOptions: [{\n    type: Input\n  }],\n  waypoints: [{\n    type: Input\n  }],\n  optimizeWaypoints: [{\n    type: Input\n  }],\n  provideRouteAlternatives: [{\n    type: Input\n  }],\n  avoidHighways: [{\n    type: Input\n  }],\n  avoidTolls: [{\n    type: Input\n  }],\n  renderOptions: [{\n    type: Input\n  }],\n  panel: [{\n    type: Input\n  }],\n  markerOptions: [{\n    type: Input\n  }],\n  infoWindow: [{\n    type: Input\n  }],\n  visible: [{\n    type: Input\n  }],\n  renderRoute: [{\n    type: Input\n  }],\n  onChange: [{\n    type: Output\n  }],\n  onResponse: [{\n    type: Output\n  }],\n  sendInfoWindow: [{\n    type: Output\n  }],\n  status: [{\n    type: Output\n  }],\n  originDrag: [{\n    type: Output\n  }],\n  destinationDrag: [{\n    type: Output\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AgmDirection, [{\n    type: Directive,\n    args: [{\n      selector: 'agm-direction'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc1.GoogleMapsAPIWrapper\n    }];\n  }, {\n    travelMode: [{\n      type: Input\n    }],\n    transitOptions: [{\n      type: Input\n    }],\n    drivingOptions: [{\n      type: Input\n    }],\n    waypoints: [{\n      type: Input\n    }],\n    optimizeWaypoints: [{\n      type: Input\n    }],\n    provideRouteAlternatives: [{\n      type: Input\n    }],\n    avoidHighways: [{\n      type: Input\n    }],\n    avoidTolls: [{\n      type: Input\n    }],\n    visible: [{\n      type: Input\n    }],\n    onChange: [{\n      type: Output\n    }],\n    onResponse: [{\n      type: Output\n    }],\n    sendInfoWindow: [{\n      type: Output\n    }],\n    status: [{\n      type: Output\n    }],\n    originDrag: [{\n      type: Output\n    }],\n    destinationDrag: [{\n      type: Output\n    }],\n    renderRoute: [{\n      type: Input\n    }],\n    origin: [{\n      type: Input\n    }],\n    destination: [{\n      type: Input\n    }],\n    infoWindow: [{\n      type: Input\n    }],\n    renderOptions: [{\n      type: Input\n    }],\n    panel: [{\n      type: Input\n    }],\n    markerOptions: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nvar AgmDirectionModule = /*#__PURE__*/function () {\n  function AgmDirectionModule() {\n    _classCallCheck(this, AgmDirectionModule);\n  }\n\n  _createClass(AgmDirectionModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * @return {?}\n     */\n    function forRoot() {\n      return {\n        ngModule: AgmDirectionModule\n      };\n    }\n  }]);\n\n  return AgmDirectionModule;\n}();\n\nAgmDirectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: AgmDirectionModule\n});\nAgmDirectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function AgmDirectionModule_Factory(t) {\n    return new (t || AgmDirectionModule)();\n  },\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmDirectionModule, {\n    declarations: [AgmDirection],\n    exports: [AgmDirection]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(AgmDirectionModule, [{\n    type: NgModule,\n    args: [{\n      imports: [],\n      declarations: [AgmDirection],\n      exports: [AgmDirection]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n\nexport { AgmDirectionModule, AgmDirection as ɵa };","map":{"version":3,"sources":["../package/src/directive/agm-direction.directive.ts","../package/src/modules/agm-direction.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Directive, Input, Output, OnChanges, OnInit, EventEmitter, OnDestroy } from '@angular/core';\nimport { GoogleMapsAPIWrapper } from '@agm/core';\nimport { InfoWindow, GoogleMap, Marker } from '@agm/core/services/google-maps-types';\n\ndeclare var google: any;\n@Directive({\n  selector: 'agm-direction',\n})\nexport class AgmDirection implements OnChanges, OnInit, OnDestroy {\n\n  // LatLng | String | google.maps.Place\n  @Input() origin: any;\n\n  // LatLng | String | google.maps.Place\n  @Input() destination: any;\n\n  // Options\n  @Input() travelMode: String = 'DRIVING';\n  @Input() transitOptions: any = undefined;\n  @Input() drivingOptions: any = undefined;\n  @Input() waypoints: any = [];\n  @Input() optimizeWaypoints: Boolean = true;\n  @Input() provideRouteAlternatives: Boolean = false;\n  @Input() avoidHighways: Boolean = false;\n  @Input() avoidTolls: Boolean = false;\n  @Input() renderOptions: any;\n  @Input() panel: object | undefined;\n  @Input() markerOptions: { origin: any, destination: any, waypoints: any };\n  @Input() infoWindow: InfoWindow;\n\n  // Remove or draw direction\n  @Input() visible: Boolean = true;\n\n  // Render exist direction\n  @Input() renderRoute: any;\n\n  // Direction change event handler\n  @Output() onChange: EventEmitter<any> = new EventEmitter<any>();\n\n  // Direction response for the new request\n  @Output() onResponse: EventEmitter<any> = new EventEmitter<any>();\n\n  // Send a custom infowindow\n  @Output() sendInfoWindow: EventEmitter<InfoWindow> = new EventEmitter<InfoWindow>();\n\n  // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)\n  @Output() status: EventEmitter<string> = new EventEmitter<string>();\n\n  // Marker drag event handler\n  @Output() originDrag: EventEmitter<any> = new EventEmitter<any>();\n  @Output() destinationDrag: EventEmitter<any> = new EventEmitter<any>();\n\n  public directionsService: any = undefined;\n  public directionsDisplay: any = undefined;\n\n  // Use for custom marker\n  private originMarker: any;\n  private destinationMarker: any;\n  private waypointsMarker: any = [];\n\n  // Use for visible flag\n  private isFirstChange: Boolean = true;\n\n  constructor(\n    private gmapsApi: GoogleMapsAPIWrapper,\n  ) { }\n\n  ngOnInit() {\n    if (this.visible === true) {\n      this.directionDraw();\n    }\n  }\n\n  ngOnChanges(obj: any) {\n    /**\n     * When visible is false then remove the direction layer\n     */\n    if (!this.visible) {\n      try {\n        this.removeMarkers();\n        this.removeDirections();\n      } catch (e) { }\n    } else {\n      if (this.isFirstChange) {\n        /**\n         * When visible is false at the first time\n         */\n        if (typeof this.directionsDisplay === 'undefined') {\n          this.directionDraw();\n        }\n        this.isFirstChange = false;\n        return;\n      }\n\n      /**\n       * When renderOptions are not first change then reset the display\n       */\n      if (typeof obj.renderOptions !== 'undefined') {\n        if (obj.renderOptions.firstChange === false) {\n          this.removeMarkers();\n          this.removeDirections();\n        }\n      }\n      this.directionDraw();\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyMarkers();\n    this.removeDirections();\n  }\n\n  /**\n   * This event is fired when the user creating or updating this direction\n   */\n  private directionDraw() {\n    this.gmapsApi.getNativeMap().then((map: GoogleMap) => {\n\n      if (typeof this.directionsDisplay === 'undefined') {\n        this.directionsDisplay = new google.maps.DirectionsRenderer(this.renderOptions);\n        this.directionsDisplay.setMap(map);\n        this.directionsDisplay.addListener('directions_changed', () => {\n          this.onChange.emit(this.directionsDisplay.getDirections());\n        });\n      }\n\n      if (typeof this.directionsService === 'undefined') {\n        this.directionsService = new google.maps.DirectionsService;\n      }\n\n      if (typeof this.panel === 'undefined') {\n        this.directionsDisplay.setPanel(null);\n      } else {\n        this.directionsDisplay.setPanel(this.panel);\n      }\n\n      // Render exist direction\n      if (typeof this.renderRoute === 'object' && this.renderRoute !== null) {\n        this.directionsDisplay.setDirections(this.renderRoute);\n        this.renderRoute = null; // or set undefined, ''\n      } else {\n\n        // Request new direction\n        this.directionsService.route({\n          origin: this.origin,\n          destination: this.destination,\n          travelMode: this.travelMode,\n          transitOptions: this.transitOptions,\n          drivingOptions: this.drivingOptions,\n          waypoints: this.waypoints,\n          optimizeWaypoints: this.optimizeWaypoints,\n          provideRouteAlternatives: this.provideRouteAlternatives,\n          avoidHighways: this.avoidHighways,\n          avoidTolls: this.avoidTolls,\n        }, (response: any, status: any) => {\n\n          this.onResponse.emit(response);\n\n          // Emit Query Status\n          this.status.emit(status);\n\n          /**\n           * DirectionsStatus\n           * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus\n           */\n          switch (status) {\n            case 'OK':\n              this.directionsDisplay.setDirections(response);\n\n              /**\n               * Emit The DirectionsResult Object\n               * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults\n               */\n              // Custom Markers\n              if (typeof this.markerOptions !== 'undefined') {\n\n                this.destroyMarkers();\n\n                // Set custom markers\n                const _route = response.routes[0].legs[0];\n                try {\n                  // Origin Marker\n                  if (typeof this.markerOptions.origin !== 'undefined') {\n                    this.markerOptions.origin.map = map;\n                    this.markerOptions.origin.position = _route.start_location;\n                    this.originMarker = this.setMarker(\n                      map,\n                      this.originMarker,\n                      this.markerOptions.origin,\n                      _route.start_address,\n                    );\n\n                    if (this.markerOptions.origin.draggable) {\n                      this.originMarker.addListener('dragend', () => {\n                        this.origin = this.originMarker.position;\n                        this.directionDraw();\n                        this.originDrag.emit(this.origin);\n                      });\n                    }\n                  }\n                  // Destination Marker\n                  if (typeof this.markerOptions.destination !== 'undefined') {\n                    this.markerOptions.destination.map = map;\n                    this.markerOptions.destination.position = _route.end_location;\n                    this.destinationMarker = this.setMarker(\n                      map,\n                      this.destinationMarker,\n                      this.markerOptions.destination,\n                      _route.end_address,\n                    );\n                    if (this.markerOptions.destination.draggable) {\n                      this.destinationMarker.addListener('dragend', () => {\n                        this.destination = this.destinationMarker.position;\n                        this.directionDraw();\n                        this.destinationDrag.emit(this.destination);\n                      });\n                    }\n                  }\n\n                  // Waypoints Marker\n                  if (typeof this.markerOptions.waypoints !== 'undefined') {\n\n                    this.waypoints.forEach((waypoint: any, index: number) => {\n\n                      // If waypoints are not array then set all the same\n                      if (!Array.isArray(this.markerOptions.waypoints)) {\n                        this.markerOptions.waypoints.map = map;\n                        this.markerOptions.waypoints.position = _route.via_waypoints[index];\n                        this.waypointsMarker.push(this.setMarker(\n                          map,\n                          waypoint,\n                          this.markerOptions.waypoints,\n                          _route.via_waypoints[index],\n                        ));\n                      } else {\n                        this.markerOptions.waypoints[index].map = map;\n                        this.markerOptions.waypoints[index].position = _route.via_waypoints[index];\n                        this.waypointsMarker.push(this.setMarker(\n                          map,\n                          waypoint,\n                          this.markerOptions.waypoints[index],\n                          _route.via_waypoints[index],\n                        ));\n                      }\n\n                    }); // End forEach\n\n                  }\n                } catch (err) {\n                  console.error('MarkerOptions error.', err);\n                }\n              }\n\n              break;\n\n            default:\n              // console.warn(status);\n              break;\n          } // End switch\n        });\n      }\n    });\n  }\n\n  /**\n   * Custom Origin and Destination Icon\n   * @param map map\n   * @param marker marker\n   * @param markerOpts properties\n   * @param content marker's infowindow content\n   * @returns new marker\n   * @memberof AgmDirection\n   */\n  private setMarker(map: GoogleMap, marker: any, markerOpts: any, content: string): Marker {\n    if (typeof this.infoWindow === 'undefined') {\n      this.infoWindow = new google.maps.InfoWindow({});\n      this.sendInfoWindow.emit(this.infoWindow);\n    }\n    marker = new google.maps.Marker(markerOpts);\n    // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable\n    if (marker.clickable) {\n      marker.addListener('click', () => {\n        const infowindoContent: string = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;\n        this.infoWindow.setContent(infowindoContent);\n        this.infoWindow.open(map, marker);\n      });\n    }\n    return marker;\n  }\n\n  /**\n   * This event is fired when remove markers\n   */\n  private removeMarkers(): void {\n    if (typeof this.originMarker !== 'undefined') {\n      this.originMarker.setMap(null);\n    }\n    if (typeof this.destinationMarker !== 'undefined') {\n      this.destinationMarker.setMap(null);\n    }\n    this.waypointsMarker.forEach((w: any) => {\n      if (typeof w !== 'undefined') {\n        w.setMap(null);\n      }\n    });\n  }\n\n  /**\n   * This event is fired when remove directions\n   */\n  private removeDirections(): void {\n    if (this.directionsDisplay !== undefined) {\n      this.directionsDisplay.setPanel(null);\n      this.directionsDisplay.setMap(null);\n      this.directionsDisplay = undefined;\n    }\n  }\n\n  /**\n   * This event is fired when destroy markers\n   */\n  private destroyMarkers(): void {\n    // Remove origin markers\n    try {\n      if (typeof this.originMarker !== 'undefined') {\n        google.maps.event.clearListeners(this.originMarker, 'click');\n        if (this.markerOptions.origin.draggable) {\n          google.maps.event.clearListeners(this.originMarker, 'dragend');\n        }\n      }\n      if (typeof this.destinationMarker !== 'undefined') {\n        google.maps.event.clearListeners(this.destinationMarker, 'click');\n        if (this.markerOptions.origin.draggable) {\n          google.maps.event.clearListeners(this.destinationMarker, 'dragend');\n        }\n      }\n      this.waypointsMarker.forEach((w: any) => {\n        if (typeof w !== 'undefined') {\n          google.maps.event.clearListeners(w, 'click');\n        }\n      });\n      this.removeMarkers();\n\n    } catch (err) {\n      console.error('Can not reset custom marker.', err);\n    }\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { AgmDirection } from '../directive/agm-direction.directive';\n\nexport * from '../directive/agm-direction.directive';\n\n@NgModule({\n    imports: [],\n    declarations: [\n        AgmDirection,\n    ],\n    exports: [\n        AgmDirection,\n    ]\n})\nexport class AgmDirectionModule {\n    static forRoot(): ModuleWithProviders {\n        return {\n            ngModule: AgmDirectionModule,\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}