{"ast":null,"code":"import _inherits from \"/Users/zahangiralam/Desktop/Projects/ITA/hotelswave-frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/zahangiralam/Desktop/Projects/ITA/hotelswave-frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/zahangiralam/Desktop/Projects/ITA/hotelswave-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/zahangiralam/Desktop/Projects/ITA/hotelswave-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Inject, Injectable, InjectionToken, Injector, NgModule } from '@angular/core';\nimport { APP_BASE_HREF } from '@angular/common';\nimport { REQUEST, RESPONSE } from '@nguniversal/express-engine/tokens';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} obj\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction isBlank(obj) {\n  return obj === undefined || obj === null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isPresent(obj) {\n  return obj !== undefined && obj !== null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n/**\n * @param {?} oldOptions\n * @param {?=} newOptions\n * @return {?}\n */\n\n\nfunction mergeOptions(oldOptions, newOptions) {\n  if (!newOptions) {\n    return oldOptions;\n  }\n\n  return {\n    path: isPresent(newOptions.path) ? newOptions.path : oldOptions.path,\n    domain: isPresent(newOptions.domain) ? newOptions.domain : oldOptions.domain,\n    expires: isPresent(newOptions.expires) ? newOptions.expires : oldOptions.expires,\n    secure: isPresent(newOptions.secure) ? newOptions.secure : oldOptions.secure,\n    httpOnly: isPresent(newOptions.httpOnly) ? newOptions.httpOnly : oldOptions.httpOnly,\n    storeUnencoded: isPresent(newOptions.storeUnencoded) ? newOptions.storeUnencoded : oldOptions.storeUnencoded\n  };\n}\n/**\n * @param {?} str\n * @return {?}\n */\n\n\nfunction safeDecodeURIComponent(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (e) {\n    return str;\n  }\n}\n/**\n * @param {?} str\n * @return {?}\n */\n\n\nfunction safeJsonParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return str;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar COOKIE_OPTIONS = new InjectionToken('COOKIE_OPTIONS');\n\nvar CookieOptionsProvider = /*@__PURE__*/function () {\n  var CookieOptionsProvider = /*#__PURE__*/function () {\n    /**\n     * @param {?=} options\n     * @param {?=} _injector\n     */\n    function CookieOptionsProvider() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _injector = arguments.length > 1 ? arguments[1] : undefined;\n\n      _classCallCheck(this, CookieOptionsProvider);\n\n      this._injector = _injector;\n      this.defaultOptions = {\n        path: this._injector.get(APP_BASE_HREF, '/'),\n        domain: null,\n        expires: null,\n        secure: false,\n        httpOnly: false\n      };\n      this._options = mergeOptions(this.defaultOptions, options);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(CookieOptionsProvider, [{\n      key: \"options\",\n      get: function get() {\n        return this._options;\n      }\n    }]);\n\n    return CookieOptionsProvider;\n  }();\n\n  CookieOptionsProvider.ɵfac = function CookieOptionsProvider_Factory(t) {\n    return new (t || CookieOptionsProvider)(ɵngcc0.ɵɵinject(COOKIE_OPTIONS), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  CookieOptionsProvider.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: CookieOptionsProvider,\n    factory: CookieOptionsProvider.ɵfac\n  });\n  return CookieOptionsProvider;\n}();\n\nvar CookieService = /*@__PURE__*/function () {\n  var CookieService = /*#__PURE__*/function () {\n    /**\n     * @param {?} _optionsProvider\n     */\n    function CookieService(_optionsProvider) {\n      _classCallCheck(this, CookieService);\n\n      this._optionsProvider = _optionsProvider;\n      this.options = this._optionsProvider.options;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(CookieService, [{\n      key: \"cookieString\",\n      get: function get() {\n        return document.cookie || '';\n      }\n      /**\n       * @param {?} val\n       * @return {?}\n       */\n      ,\n      set: function set(val) {\n        document.cookie = val;\n      }\n      /**\n       * \\@name CookieService#get\n       *\n       * \\@description\n       * Returns the value of given cookie key.\n       *\n       * @param {?} key Id to use for lookup.\n       * @return {?} Raw cookie value.\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        return this._cookieReader()[key];\n      }\n      /**\n       * \\@name CookieService#getObject\n       *\n       * \\@description\n       * Returns the deserialized value of given cookie key.\n       *\n       * @param {?} key Id to use for lookup.\n       * @return {?} Deserialized cookie value.\n       */\n\n    }, {\n      key: \"getObject\",\n      value: function getObject(key) {\n        /** @type {?} */\n        var value = this.get(key);\n        return value ? safeJsonParse(value) : value;\n      }\n      /**\n       * \\@name CookieService#getAll\n       *\n       * \\@description\n       * Returns a key value object with all the cookies.\n       *\n       * @return {?} All cookies\n       */\n\n    }, {\n      key: \"getAll\",\n      value: function getAll() {\n        return this._cookieReader();\n      }\n      /**\n       * \\@name CookieService#put\n       *\n       * \\@description\n       * Sets a value for given cookie key.\n       *\n       * @param {?} key Id for the `value`.\n       * @param {?} value Raw value to be stored.\n       * @param {?=} options (Optional) Options object.\n       * @return {?}\n       */\n\n    }, {\n      key: \"put\",\n      value: function put(key, value, options) {\n        this._cookieWriter()(key, value, options);\n      }\n      /**\n       * \\@name CookieService#putObject\n       *\n       * \\@description\n       * Serializes and sets a value for given cookie key.\n       *\n       * @param {?} key Id for the `value`.\n       * @param {?} value Value to be stored.\n       * @param {?=} options (Optional) Options object.\n       * @return {?}\n       */\n\n    }, {\n      key: \"putObject\",\n      value: function putObject(key, value, options) {\n        this.put(key, JSON.stringify(value), options);\n      }\n      /**\n       * \\@name CookieService#remove\n       *\n       * \\@description\n       * Remove given cookie.\n       *\n       * @param {?} key Id of the key-value pair to delete.\n       * @param {?=} options (Optional) Options object.\n       * @return {?}\n       */\n\n    }, {\n      key: \"remove\",\n      value: function remove(key, options) {\n        this._cookieWriter()(key, undefined, options);\n      }\n      /**\n       * \\@name CookieService#removeAll\n       *\n       * \\@description\n       * Remove all cookies.\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"removeAll\",\n      value: function removeAll(options) {\n        var _this = this;\n\n        /** @type {?} */\n        var cookies = this.getAll();\n        Object.keys(cookies).forEach(function (key) {\n          _this.remove(key, options);\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_cookieReader\",\n      value: function _cookieReader() {\n        /** @type {?} */\n        var lastCookies = {};\n        /** @type {?} */\n\n        var lastCookieString = '';\n        /** @type {?} */\n\n        var cookieArray;\n        /** @type {?} */\n\n        var cookie;\n        /** @type {?} */\n\n        var i;\n        /** @type {?} */\n\n        var index;\n        /** @type {?} */\n\n        var name;\n        /** @type {?} */\n\n        var currentCookieString = this.cookieString;\n\n        if (currentCookieString !== lastCookieString) {\n          lastCookieString = currentCookieString;\n          cookieArray = lastCookieString.split('; ');\n          lastCookies = {};\n\n          for (i = 0; i < cookieArray.length; i++) {\n            cookie = cookieArray[i];\n            index = cookie.indexOf('=');\n\n            if (index > 0) {\n              // ignore nameless cookies\n              name = safeDecodeURIComponent(cookie.substring(0, index)); // the first value that is seen for a cookie is the most\n              // specific one.  values for the same cookie name that\n              // follow are for less specific paths.\n\n              if (isBlank(lastCookies[name])) {\n                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));\n              }\n            }\n          }\n        }\n\n        return lastCookies;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"_cookieWriter\",\n      value: function _cookieWriter() {\n        /** @type {?} */\n        var that = this;\n        return function (name, value, options) {\n          that.cookieString = that._buildCookieString(name, value, options);\n        };\n      }\n      /**\n       * @param {?} name\n       * @param {?} value\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"_buildCookieString\",\n      value: function _buildCookieString(name, value, options) {\n        /** @type {?} */\n        var opts = mergeOptions(this.options, options);\n        /** @type {?} */\n\n        var expires = opts.expires;\n\n        if (isBlank(value)) {\n          expires = 'Thu, 01 Jan 1970 00:00:00 GMT';\n          value = '';\n        }\n\n        if (isString(expires)) {\n          expires = new Date(expires);\n        }\n        /** @type {?} */\n\n\n        var cookieValue = opts.storeUnencoded ? value : encodeURIComponent(value);\n        /** @type {?} */\n\n        var str = encodeURIComponent(name) + '=' + cookieValue;\n        str += opts.path ? ';path=' + opts.path : '';\n        str += opts.domain ? ';domain=' + opts.domain : '';\n        str += expires ? ';expires=' + expires.toUTCString() : '';\n        str += opts.secure ? ';secure' : '';\n        str += opts.httpOnly ? '; HttpOnly' : ''; // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n        // - 300 cookies\n        // - 20 cookies per unique domain\n        // - 4096 bytes per cookie\n\n        /** @type {?} */\n\n        var cookieLength = str.length + 1;\n\n        if (cookieLength > 4096) {\n          console.log(\"Cookie '\".concat(name, \"' possibly not set or overflowed because it was too large (\").concat(cookieLength, \" > 4096 bytes)!\"));\n        }\n\n        return str;\n      }\n    }]);\n\n    return CookieService;\n  }();\n\n  CookieService.ɵfac = function CookieService_Factory(t) {\n    return new (t || CookieService)(ɵngcc0.ɵɵinject(CookieOptionsProvider));\n  };\n\n  CookieService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: CookieService,\n    factory: CookieService.ɵfac\n  });\n  return CookieService;\n}();\n\nvar CookieBackendService = /*@__PURE__*/function () {\n  var CookieBackendService = /*#__PURE__*/function (_CookieService) {\n    _inherits(CookieBackendService, _CookieService);\n\n    var _super = _createSuper(CookieBackendService);\n\n    /**\n     * @param {?} request\n     * @param {?} response\n     * @param {?} _optionsProvider\n     */\n    function CookieBackendService(request, response, _optionsProvider) {\n      var _this2;\n\n      _classCallCheck(this, CookieBackendService);\n\n      _this2 = _super.call(this, _optionsProvider);\n      _this2.request = request;\n      _this2.response = response;\n      return _this2;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(CookieBackendService, [{\n      key: \"cookieString\",\n      get: function get() {\n        return this.request.cookie || '';\n      }\n      /**\n       * @param {?} val\n       * @return {?}\n       */\n      ,\n      set: function set(val) {\n        this.request.cookie = val;\n        this.response.cookie = val;\n      }\n    }]);\n\n    return CookieBackendService;\n  }(CookieService);\n\n  CookieBackendService.ɵfac = function CookieBackendService_Factory(t) {\n    return new (t || CookieBackendService)(ɵngcc0.ɵɵinject(REQUEST), ɵngcc0.ɵɵinject(RESPONSE), ɵngcc0.ɵɵinject(CookieOptionsProvider));\n  };\n\n  CookieBackendService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: CookieBackendService,\n    factory: CookieBackendService.ɵfac\n  });\n  return CookieBackendService;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} cookieOptionsProvider\n * @return {?}\n */\n\n\nfunction cookieServiceFactory(cookieOptionsProvider) {\n  return new CookieService(cookieOptionsProvider);\n}\n\nvar CookieModule = /*@__PURE__*/function () {\n  var CookieModule = /*#__PURE__*/function () {\n    function CookieModule() {\n      _classCallCheck(this, CookieModule);\n    }\n\n    _createClass(CookieModule, null, [{\n      key: \"forRoot\",\n      value:\n      /**\n       * Use this method in your root module to provide the CookieService\n       * @param {?=} options\n       * @return {?}\n       */\n      function forRoot() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: CookieModule,\n          providers: [{\n            provide: COOKIE_OPTIONS,\n            useValue: options\n          }, {\n            provide: CookieService,\n            useFactory: cookieServiceFactory,\n            deps: [CookieOptionsProvider]\n          }]\n        };\n      }\n      /**\n       * Use this method in your other (non root) modules to import the directive/pipe\n       * @param {?=} options\n       * @return {?}\n       */\n\n    }, {\n      key: \"forChild\",\n      value: function forChild() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return {\n          ngModule: CookieModule,\n          providers: [{\n            provide: COOKIE_OPTIONS,\n            useValue: options\n          }, {\n            provide: CookieService,\n            useFactory: cookieServiceFactory,\n            deps: [CookieOptionsProvider]\n          }]\n        };\n      }\n    }]);\n\n    return CookieModule;\n  }();\n\n  CookieModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: CookieModule\n  });\n  CookieModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function CookieModule_Factory(t) {\n      return new (t || CookieModule)();\n    },\n    providers: [CookieOptionsProvider]\n  });\n  return CookieModule;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\n\n\nexport { CookieService, CookieBackendService, COOKIE_OPTIONS, CookieOptionsProvider, cookieServiceFactory, isBlank, isPresent, isString, mergeOptions, safeDecodeURIComponent, safeJsonParse, CookieModule };","map":null,"metadata":{},"sourceType":"module"}