(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('ng2-pica'),exports, require('@angular/core'), require('rxjs'), require('exifr/dist/mini.legacy.umd'), require('ng2-pica')) :
	typeof define === 'function' && define.amd ? define(['@angular/core','ng2-pica','exports', '@angular/core', 'rxjs', 'exifr/dist/mini.legacy.umd', 'ng2-pica'], factory) :
	(factory(global.ng.core,global.ng2Pica,(global['ng2-img-max'] = global['ng2-img-max'] || {}),global.ng.core,global.Rx,global.exifr,global.ng2Pica));
}(this, (function (ɵngcc0,ɵngcc1,exports,_angular_core,rxjs,exifr,ng2Pica) { 'use strict';

var ImgExifService = /** @class */ (function () {
    function ImgExifService() {
    }
    ImgExifService.prototype.getOrientedImage = function (image) {
        return new Promise(function (resolve) {
            var img;
            exifr.orientation(image).catch(function (err) { return undefined; }).then(function (orientation$$1) {
                if (orientation$$1 != 1) {
                    var canvas = document.createElement("canvas"), ctx = canvas.getContext("2d"), cw = image.width, ch = image.height, cx = 0, cy = 0, deg = 0;
                    switch (orientation$$1) {
                        case 3:
                        case 4:
                            cx = -image.width;
                            cy = -image.height;
                            deg = 180;
                            break;
                        case 5:
                        case 6:
                            cw = image.height;
                            ch = image.width;
                            cy = -image.height;
                            deg = 90;
                            break;
                        case 7:
                        case 8:
                            cw = image.height;
                            ch = image.width;
                            cx = -image.width;
                            deg = 270;
                            break;
                        default:
                            break;
                    }
                    canvas.width = cw;
                    canvas.height = ch;
                    if ([2, 4, 5, 7].indexOf(orientation$$1) > -1) {
                        //flip image
                        ctx.translate(cw, 0);
                        ctx.scale(-1, 1);
                    }
                    ctx.rotate(deg * Math.PI / 180);
                    ctx.drawImage(image, cx, cy);
                    img = document.createElement("img");
                    img.width = cw;
                    img.height = ch;
                    img.addEventListener('load', function () {
                        resolve(img);
                    });
                    img.src = canvas.toDataURL("image/png");
                }
                else {
                    resolve(image);
                }
            });
        });
    };
ImgExifService.ɵfac = function ImgExifService_Factory(t) { return new (t || ImgExifService)(); };
ImgExifService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ImgExifService, factory: function (t) { return ImgExifService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ImgExifService, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
    return ImgExifService;
}());

var MAX_STEPS = 15;
var ImgMaxSizeService = /** @class */ (function () {
    function ImgMaxSizeService(imageExifService) {
        this.imageExifService = imageExifService;
    }
    ImgMaxSizeService.prototype.compressImage = function (file, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        var _this = this;
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var compressedFileSubject = new rxjs.Subject();
        this.timeAtStart = new Date().getTime();
        this.initialFile = file;
        if (file.type !== "image/jpeg" && file.type !== "image/png") {
            //END OF COMPRESSION
            setTimeout(function () {
                compressedFileSubject.error({ compressedFile: file, reason: "File provided is neither of type jpg nor of type png.", error: "INVALID_EXTENSION" });
            }, 0);
            return compressedFileSubject.asObservable();
        }
        var oldFileSize = file.size / 1024 / 1024;
        if (oldFileSize < maxSizeInMB) {
            // END OF COMPRESSION
            // FILE SIZE ALREADY BELOW MAX_SIZE -> no compression needed
            setTimeout(function () { compressedFileSubject.next(file); }, 0);
            return compressedFileSubject.asObservable();
        }
        var cvs = document.createElement('canvas');
        var ctx = cvs.getContext('2d');
        var img = new Image();
        var self = this;
        img.onload = function () {
            _this.imageExifService.getOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                cvs.width = orientedImg.width;
                cvs.height = orientedImg.height;
                ctx.drawImage(orientedImg, 0, 0);
                var imageData = ctx.getImageData(0, 0, orientedImg.width, orientedImg.height);
                if (file.type === "image/png" && _this.isImgUsingAlpha(imageData) && !ignoreAlpha) {
                    //png image with alpha
                    compressedFileSubject.error({ compressedFile: file, reason: "File provided is a png image which uses the alpha channel. No compression possible.", error: "PNG_WITH_ALPHA" });
                }
                ctx = cvs.getContext('2d', { 'alpha': false });
                ctx.drawImage(orientedImg, 0, 0);
                self.getCompressedFile(cvs, 50, maxSizeInMB, 1).then(function (compressedFile) {
                    compressedFileSubject.next(compressedFile);
                    self.logExecutionTime(logExecutionTime);
                }).catch(function (error) {
                    compressedFileSubject.error(error);
                    self.logExecutionTime(logExecutionTime);
                });
            });
        };
        img.src = window.URL.createObjectURL(file);
        return compressedFileSubject.asObservable();
    };
    
    ImgMaxSizeService.prototype.getCompressedFile = function (cvs, quality, maxSizeInMB, currentStep) {
        var _this = this;
        var result = new Promise(function (resolve, reject) {
            cvs.toBlob(function (blob) {
                if (currentStep + 1 > MAX_STEPS) {
                    //COMPRESSION END
                    //maximal steps reached
                    reject({ compressedFile: _this.getResultFile(blob), reason: "Could not find the correct compression quality in " + MAX_STEPS + " steps.", error: "MAX_STEPS_EXCEEDED" });
                }
                else {
                    var newQuality = _this.getCalculatedQuality(blob, quality, maxSizeInMB, currentStep);
                    _this.checkCompressionStatus(cvs, blob, quality, maxSizeInMB, currentStep, newQuality)
                        .then(function (result) {
                        resolve(result);
                    })
                        .catch(function (result) {
                        reject(result);
                    });
                }
            }, "image/jpeg", quality / 100);
        });
        return result;
    };
    ImgMaxSizeService.prototype.getResultFile = function (blob) {
        return this.generateResultFile(blob, this.initialFile.name, this.initialFile.type, new Date().getTime());
    };
    ImgMaxSizeService.prototype.generateResultFile = function (blob, name, type, lastModified) {
        var resultFile = new Blob([blob], { type: type });
        return this.blobToFile(resultFile, name, lastModified);
    };
    ImgMaxSizeService.prototype.blobToFile = function (blob, name, lastModified) {
        var file = blob;
        file.name = name;
        file.lastModified = lastModified;
        //Cast to a File() type
        return file;
    };
    ImgMaxSizeService.prototype.getCalculatedQuality = function (blob, quality, maxSizeInMB, currentStep) {
        //CALCULATE NEW QUALITY
        var currentSize = blob.size / 1024 / 1024;
        var ratioMaxSizeToCurrentSize = maxSizeInMB / currentSize;
        if (ratioMaxSizeToCurrentSize > 5) {
            //max ratio to avoid extreme quality values
            ratioMaxSizeToCurrentSize = 5;
        }
        var ratioMaxSizeToInitialSize = currentSize / (this.initialFile.size / 1024 / 1024);
        if (ratioMaxSizeToInitialSize < 0.05) {
            //min ratio to avoid extreme quality values
            ratioMaxSizeToInitialSize = 0.05;
        }
        var newQuality = 0;
        var multiplicator = Math.abs(ratioMaxSizeToInitialSize - 1) * 10 / (currentStep * 1.7) / ratioMaxSizeToCurrentSize;
        if (multiplicator < 1) {
            multiplicator = 1;
        }
        if (ratioMaxSizeToCurrentSize >= 1) {
            newQuality = quality + (ratioMaxSizeToCurrentSize - 1) * 10 * multiplicator;
        }
        else {
            newQuality = quality - (1 - ratioMaxSizeToCurrentSize) * 10 * multiplicator;
        }
        if (newQuality > 100) {
            //max quality = 100, so let's set the new quality to the value in between the old quality and 100 in case of > 100
            newQuality = quality + (100 - quality) / 2;
        }
        if (newQuality < 0) {
            //min quality = 0, so let's set the new quality to the value in between the old quality and 0 in case of < 0
            newQuality = quality - quality / 2;
        }
        return newQuality;
    };
    ImgMaxSizeService.prototype.checkCompressionStatus = function (cvs, blob, quality, maxSizeInMB, currentStep, newQuality) {
        var _this = this;
        var result = new Promise(function (resolve, reject) {
            if (quality === 100 && newQuality >= 100) {
                //COMPRESSION END
                //Seems like quality 100 is max but file still too small, case that shouldn't exist as the compression shouldn't even have started in the first place
                reject({ compressedFile: _this.initialFile, reason: "Unfortunately there was an error while compressing the file.", error: "FILE_BIGGER_THAN_INITIAL_FILE" });
            }
            else if ((quality < 1) && (newQuality < quality)) {
                //COMPRESSION END
                //File size still too big but can't compress further than quality=0
                reject({ compressedFile: _this.getResultFile(blob), reason: "Could not compress image enough to fit the maximal file size limit.", error: "UNABLE_TO_COMPRESS_ENOUGH" });
            }
            else if ((newQuality > quality) && (Math.round(quality) == Math.round(newQuality))) {
                //COMPRESSION END
                //next steps quality would be the same quality but newQuality is slightly bigger than old one, means we most likely found the nearest quality to compress to maximal size
                resolve(_this.getResultFile(blob));
            }
            else if (currentStep > 5 && (newQuality > quality) && (newQuality < quality + 2)) {
                //COMPRESSION END
                //for some rare occasions the algorithm might be stuck around e.g. 98.5 and 97.4 because of the maxQuality of 100, the current quality is the nearest possible quality in that case
                resolve(_this.getResultFile(blob));
            }
            else if ((newQuality > quality) && Number.isInteger(quality) && (Math.floor(newQuality) == quality)) {
                //COMPRESSION END
                /*
                    in the previous step if ((quality > newQuality) && (Math.round(quality) == Math.round(newQuality))) applied, so
                    newQuality = Math.round(newQuality) - 1; this was done to reduce the quality at least a full integer down to not waste a step
                    with the same compression rate quality as before. Now, the newQuality is still only in between the old quality (e.g. 93)
                    and the newQuality (e.g. 94) which most likely means that the value for the newQuality (the bigger one) would make the filesize
                    too big so we should just stick with the current, lower quality and return that file.
                */
                resolve(_this.getResultFile(blob));
            }
            else {
                //CONTINUE COMPRESSION
                if ((quality > newQuality) && (Math.round(quality) == Math.round(newQuality))) {
                    //quality can only be an integer -> make sure difference between old quality and new one is at least a whole integer number
                    // - it would be nonsense to compress again with the same quality
                    newQuality = Math.round(newQuality) - 1;
                }
                //recursively call function again
                resolve(_this.getCompressedFile(cvs, newQuality, maxSizeInMB, currentStep + 1));
            }
        });
        return result;
    };
    ImgMaxSizeService.prototype.isImgUsingAlpha = function (imageData) {
        for (var i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] !== 255) {
                return true;
            }
        }
        return false;
    };
    ImgMaxSizeService.prototype.logExecutionTime = function (logExecutionTime) {
        if (logExecutionTime) {
            console.info("Execution time: ", new Date().getTime() - this.timeAtStart + "ms");
        }
    };
    /** @nocollapse */
    ImgMaxSizeService.ctorParameters = function () { return [
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] }] }
    ]; };
ImgMaxSizeService.ɵfac = function ImgMaxSizeService_Factory(t) { return new (t || ImgMaxSizeService)(ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ImgExifService; }))); };
ImgMaxSizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ImgMaxSizeService, factory: function (t) { return ImgMaxSizeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ImgMaxSizeService, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: ImgExifService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ImgExifService; })]
            }] }]; }, null); })();
    return ImgMaxSizeService;
}());

var ImgMaxPXSizeService = /** @class */ (function () {
    function ImgMaxPXSizeService(ng2PicaService, imageExifService) {
        this.ng2PicaService = ng2PicaService;
        this.imageExifService = imageExifService;
    }
    ImgMaxPXSizeService.prototype.resizeImage = function (file, maxWidth, maxHeight, logExecutionTime) {
        var _this = this;
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var resizedFileSubject = new rxjs.Subject();
        this.timeAtStart = new Date().getTime();
        if (file.type !== "image/jpeg" && file.type !== "image/png") {
            //END OF RESIZE
            setTimeout(function () {
                resizedFileSubject.error({ resizedFile: file, reason: "The provided File is neither of type jpg nor of type png.", error: "INVALID_EXTENSION" });
            }, 0);
            return resizedFileSubject.asObservable();
        }
        var img = new Image();
        var self = this;
        img.onload = function () {
            _this.imageExifService.getOrientedImage(img).then(function (orientedImg) {
                window.URL.revokeObjectURL(img.src);
                var currentWidth = orientedImg.width;
                var currentHeight = orientedImg.height;
                var newWidth = currentWidth;
                var newHeight = currentHeight;
                if (newWidth > maxWidth) {
                    newWidth = maxWidth;
                    //resize height proportionally
                    var ratio = maxWidth / currentWidth; //is gonna be <1
                    newHeight = newHeight * ratio;
                }
                currentHeight = newHeight;
                if (newHeight > maxHeight) {
                    newHeight = maxHeight;
                    //resize width proportionally
                    var ratio = maxHeight / currentHeight; //is gonna be <1
                    newWidth = newWidth * ratio;
                }
                if (newHeight === orientedImg.height && newWidth === orientedImg.width) {
                    //no resizing necessary
                    resizedFileSubject.next(file);
                    self.logExecutionTime(logExecutionTime);
                }
                else {
                    self.ng2PicaService.resize([file], newWidth, newHeight).subscribe(function (result) {
                        //all good, result is a file
                        resizedFileSubject.next(result);
                        self.logExecutionTime(logExecutionTime);
                    }, function (error) {
                        //something went wrong 
                        resizedFileSubject.error({ resizedFile: file, reason: error, error: "PICA_ERROR" });
                        self.logExecutionTime(logExecutionTime);
                    });
                }
            });
        };
        img.src = window.URL.createObjectURL(file);
        return resizedFileSubject.asObservable();
    };
    
    ImgMaxPXSizeService.prototype.logExecutionTime = function (logExecutionTime) {
        if (logExecutionTime) {
            console.info("Execution time: ", new Date().getTime() - this.timeAtStart + "ms");
        }
    };
    /** @nocollapse */
    ImgMaxPXSizeService.ctorParameters = function () { return [
        { type: ng2Pica.Ng2PicaService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ng2Pica.Ng2PicaService; }),] }] },
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] }] }
    ]; };
ImgMaxPXSizeService.ɵfac = function ImgMaxPXSizeService_Factory(t) { return new (t || ImgMaxPXSizeService)(ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ng2Pica.Ng2PicaService; })), ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ImgExifService; }))); };
ImgMaxPXSizeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ImgMaxPXSizeService, factory: function (t) { return ImgMaxPXSizeService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ImgMaxPXSizeService, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: ɵngcc1.Ng2PicaService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ng2Pica.Ng2PicaService; })]
            }] }, { type: ImgExifService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ImgExifService; })]
            }] }]; }, null); })();
    return ImgMaxPXSizeService;
}());

var Ng2ImgMaxService = /** @class */ (function () {
    function Ng2ImgMaxService(imgMaxSizeService, imgMaxPXSizeService, imageExifService) {
        this.imgMaxSizeService = imgMaxSizeService;
        this.imgMaxPXSizeService = imgMaxPXSizeService;
        this.imageExifService = imageExifService;
    }
    Ng2ImgMaxService.prototype.compress = function (files, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        var _this = this;
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var compressedFileSubject = new rxjs.Subject();
        files.forEach(function (file) {
            _this.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime).subscribe(function (value) {
                compressedFileSubject.next(value);
            }, function (error) {
                compressedFileSubject.error(error);
            });
        });
        return compressedFileSubject.asObservable();
    };
    Ng2ImgMaxService.prototype.resize = function (files, maxWidth, maxHeight, logExecutionTime) {
        var _this = this;
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        var resizedFileSubject = new rxjs.Subject();
        files.forEach(function (file) {
            _this.resizeImage(file, maxWidth, maxHeight, logExecutionTime).subscribe(function (value) {
                resizedFileSubject.next(value);
            }, function (error) {
                resizedFileSubject.error(error);
            });
        });
        return resizedFileSubject.asObservable();
    };
    Ng2ImgMaxService.prototype.compressImage = function (file, maxSizeInMB, ignoreAlpha, logExecutionTime) {
        if (ignoreAlpha === void 0) { ignoreAlpha = false; }
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.imgMaxSizeService.compressImage(file, maxSizeInMB, ignoreAlpha, logExecutionTime);
    };
    Ng2ImgMaxService.prototype.resizeImage = function (file, maxWidth, maxHeight, logExecutionTime) {
        if (logExecutionTime === void 0) { logExecutionTime = false; }
        return this.imgMaxPXSizeService.resizeImage(file, maxWidth, maxHeight, logExecutionTime);
    };
    Ng2ImgMaxService.prototype.getEXIFOrientedImage = function (image) {
        return this.imageExifService.getOrientedImage(image);
    };
    /** @nocollapse */
    Ng2ImgMaxService.ctorParameters = function () { return [
        { type: ImgMaxSizeService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgMaxSizeService; }),] }] },
        { type: ImgMaxPXSizeService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgMaxPXSizeService; }),] }] },
        { type: ImgExifService, decorators: [{ type: _angular_core.Inject, args: [_angular_core.forwardRef(function () { return ImgExifService; }),] }] }
    ]; };
Ng2ImgMaxService.ɵfac = function Ng2ImgMaxService_Factory(t) { return new (t || Ng2ImgMaxService)(ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ImgMaxSizeService; })), ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ImgMaxPXSizeService; })), ɵngcc0.ɵɵinject(_angular_core.forwardRef(function () { return ImgExifService; }))); };
Ng2ImgMaxService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Ng2ImgMaxService, factory: function (t) { return Ng2ImgMaxService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Ng2ImgMaxService, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: ImgMaxSizeService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ImgMaxSizeService; })]
            }] }, { type: ImgMaxPXSizeService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ImgMaxPXSizeService; })]
            }] }, { type: ImgExifService, decorators: [{
                type: _angular_core.Inject,
                args: [_angular_core.forwardRef(function () { return ImgExifService; })]
            }] }]; }, null); })();
    return Ng2ImgMaxService;
}());

var Ng2ImgMaxModule = /** @class */ (function () {
    function Ng2ImgMaxModule() {
    }
Ng2ImgMaxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: Ng2ImgMaxModule });
Ng2ImgMaxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function Ng2ImgMaxModule_Factory(t) { return new (t || Ng2ImgMaxModule)(); }, providers: [
        { provide: ImgMaxPXSizeService, useClass: ImgMaxPXSizeService },
        { provide: ImgMaxSizeService, useClass: ImgMaxSizeService },
        { provide: ImgExifService, useClass: ImgExifService },
        { provide: Ng2ImgMaxService, useClass: Ng2ImgMaxService }
    ], imports: [[
            ng2Pica.Ng2PicaModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(Ng2ImgMaxModule, { imports: [ɵngcc1.Ng2PicaModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Ng2ImgMaxModule, [{
        type: _angular_core.NgModule,
        args: [{
                imports: [
                    ng2Pica.Ng2PicaModule
                ],
                providers: [
                    { provide: ImgMaxPXSizeService, useClass: ImgMaxPXSizeService },
                    { provide: ImgMaxSizeService, useClass: ImgMaxSizeService },
                    { provide: ImgExifService, useClass: ImgExifService },
                    { provide: Ng2ImgMaxService, useClass: Ng2ImgMaxService }
                ]
            }]
    }], function () { return []; }, null); })();
    return Ng2ImgMaxModule;
}());

exports.Ng2ImgMaxService = Ng2ImgMaxService;
exports.Ng2ImgMaxModule = Ng2ImgMaxModule;
exports.ImgMaxSizeService = ImgMaxSizeService;
exports.ImgMaxPXSizeService = ImgMaxPXSizeService;
exports.ImgExifService = ImgExifService;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcyLWltZy1tYXgudW1kLmpzIiwic291cmNlcyI6WyJuZzItaW1nLW1heC51bWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxxSEFBd0U7QUFDeEUsaUZBQXNEO0FBQ3RELHdDQUFVO0FBQ1YsaUNBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O2tDQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BR007QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztrQ0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUdNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztrQ0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQWFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ3J4anMnKSwgcmVxdWlyZSgnZXhpZnIvZGlzdC9taW5pLmxlZ2FjeS51bWQnKSwgcmVxdWlyZSgnbmcyLXBpY2EnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcycsICdleGlmci9kaXN0L21pbmkubGVnYWN5LnVtZCcsICduZzItcGljYSddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWxbJ25nMi1pbWctbWF4J10gPSBnbG9iYWxbJ25nMi1pbWctbWF4J10gfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeCxnbG9iYWwuZXhpZnIsZ2xvYmFsLm5nMlBpY2EpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqcyxleGlmcixuZzJQaWNhKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEltZ0V4aWZTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW1nRXhpZlNlcnZpY2UoKSB7XHJcbiAgICB9XHJcbiAgICBJbWdFeGlmU2VydmljZS5wcm90b3R5cGUuZ2V0T3JpZW50ZWRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW1nO1xyXG4gICAgICAgICAgICBleGlmci5vcmllbnRhdGlvbihpbWFnZSkuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gdW5kZWZpbmVkOyB9KS50aGVuKGZ1bmN0aW9uIChvcmllbnRhdGlvbiQkMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uJCQxICE9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSwgY3cgPSBpbWFnZS53aWR0aCwgY2ggPSBpbWFnZS5oZWlnaHQsIGN4ID0gMCwgY3kgPSAwLCBkZWcgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3JpZW50YXRpb24kJDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCA9IC1pbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gLWltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZyA9IDE4MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN3ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gLWltYWdlLmhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZyA9IDkwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3cgPSBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaCA9IGltYWdlLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAtaW1hZ2Uud2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWcgPSAyNzA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBjdztcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFsyLCA0LCA1LCA3XS5pbmRleE9mKG9yaWVudGF0aW9uJCQxKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmxpcCBpbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN3LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShkZWcgKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBjeCwgY3kpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLndpZHRoID0gY3c7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLmhlaWdodCA9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW1nRXhpZlNlcnZpY2UuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxyXG4gICAgXTtcclxuICAgIHJldHVybiBJbWdFeGlmU2VydmljZTtcclxufSgpKTtcblxudmFyIE1BWF9TVEVQUyA9IDE1O1xyXG52YXIgSW1nTWF4U2l6ZVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBJbWdNYXhTaXplU2VydmljZShpbWFnZUV4aWZTZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZUV4aWZTZXJ2aWNlID0gaW1hZ2VFeGlmU2VydmljZTtcclxuICAgIH1cclxuICAgIEltZ01heFNpemVTZXJ2aWNlLnByb3RvdHlwZS5jb21wcmVzc0ltYWdlID0gZnVuY3Rpb24gKGZpbGUsIG1heFNpemVJbk1CLCBpZ25vcmVBbHBoYSwgbG9nRXhlY3V0aW9uVGltZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlnbm9yZUFscGhhID09PSB2b2lkIDApIHsgaWdub3JlQWxwaGEgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChsb2dFeGVjdXRpb25UaW1lID09PSB2b2lkIDApIHsgbG9nRXhlY3V0aW9uVGltZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGNvbXByZXNzZWRGaWxlU3ViamVjdCA9IG5ldyByeGpzLlN1YmplY3QoKTtcclxuICAgICAgICB0aGlzLnRpbWVBdFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsRmlsZSA9IGZpbGU7XHJcbiAgICAgICAgaWYgKGZpbGUudHlwZSAhPT0gXCJpbWFnZS9qcGVnXCIgJiYgZmlsZS50eXBlICE9PSBcImltYWdlL3BuZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vRU5EIE9GIENPTVBSRVNTSU9OXHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZEZpbGVTdWJqZWN0LmVycm9yKHsgY29tcHJlc3NlZEZpbGU6IGZpbGUsIHJlYXNvbjogXCJGaWxlIHByb3ZpZGVkIGlzIG5laXRoZXIgb2YgdHlwZSBqcGcgbm9yIG9mIHR5cGUgcG5nLlwiLCBlcnJvcjogXCJJTlZBTElEX0VYVEVOU0lPTlwiIH0pO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzZWRGaWxlU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9sZEZpbGVTaXplID0gZmlsZS5zaXplIC8gMTAyNCAvIDEwMjQ7XHJcbiAgICAgICAgaWYgKG9sZEZpbGVTaXplIDwgbWF4U2l6ZUluTUIpIHtcclxuICAgICAgICAgICAgLy8gRU5EIE9GIENPTVBSRVNTSU9OXHJcbiAgICAgICAgICAgIC8vIEZJTEUgU0laRSBBTFJFQURZIEJFTE9XIE1BWF9TSVpFIC0+IG5vIGNvbXByZXNzaW9uIG5lZWRlZFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY29tcHJlc3NlZEZpbGVTdWJqZWN0Lm5leHQoZmlsZSk7IH0sIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcHJlc3NlZEZpbGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3ZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdmFyIGN0eCA9IGN2cy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaW1hZ2VFeGlmU2VydmljZS5nZXRPcmllbnRlZEltYWdlKGltZykudGhlbihmdW5jdGlvbiAob3JpZW50ZWRJbWcpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGltZy5zcmMpO1xyXG4gICAgICAgICAgICAgICAgY3ZzLndpZHRoID0gb3JpZW50ZWRJbWcud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjdnMuaGVpZ2h0ID0gb3JpZW50ZWRJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShvcmllbnRlZEltZywgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBvcmllbnRlZEltZy53aWR0aCwgb3JpZW50ZWRJbWcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUgPT09IFwiaW1hZ2UvcG5nXCIgJiYgX3RoaXMuaXNJbWdVc2luZ0FscGhhKGltYWdlRGF0YSkgJiYgIWlnbm9yZUFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wbmcgaW1hZ2Ugd2l0aCBhbHBoYVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRGaWxlU3ViamVjdC5lcnJvcih7IGNvbXByZXNzZWRGaWxlOiBmaWxlLCByZWFzb246IFwiRmlsZSBwcm92aWRlZCBpcyBhIHBuZyBpbWFnZSB3aGljaCB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLiBObyBjb21wcmVzc2lvbiBwb3NzaWJsZS5cIiwgZXJyb3I6IFwiUE5HX1dJVEhfQUxQSEFcIiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eCA9IGN2cy5nZXRDb250ZXh0KCcyZCcsIHsgJ2FscGhhJzogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKG9yaWVudGVkSW1nLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0Q29tcHJlc3NlZEZpbGUoY3ZzLCA1MCwgbWF4U2l6ZUluTUIsIDEpLnRoZW4oZnVuY3Rpb24gKGNvbXByZXNzZWRGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZEZpbGVTdWJqZWN0Lm5leHQoY29tcHJlc3NlZEZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nRXhlY3V0aW9uVGltZShsb2dFeGVjdXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzZWRGaWxlU3ViamVjdC5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2dFeGVjdXRpb25UaW1lKGxvZ0V4ZWN1dGlvblRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW1nLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgICAgIHJldHVybiBjb21wcmVzc2VkRmlsZVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5wcm90b3R5cGUuZ2V0Q29tcHJlc3NlZEZpbGUgPSBmdW5jdGlvbiAoY3ZzLCBxdWFsaXR5LCBtYXhTaXplSW5NQiwgY3VycmVudFN0ZXApIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGN2cy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RlcCArIDEgPiBNQVhfU1RFUFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0NPTVBSRVNTSU9OIEVORFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbWF4aW1hbCBzdGVwcyByZWFjaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgY29tcHJlc3NlZEZpbGU6IF90aGlzLmdldFJlc3VsdEZpbGUoYmxvYiksIHJlYXNvbjogXCJDb3VsZCBub3QgZmluZCB0aGUgY29ycmVjdCBjb21wcmVzc2lvbiBxdWFsaXR5IGluIFwiICsgTUFYX1NURVBTICsgXCIgc3RlcHMuXCIsIGVycm9yOiBcIk1BWF9TVEVQU19FWENFRURFRFwiIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1F1YWxpdHkgPSBfdGhpcy5nZXRDYWxjdWxhdGVkUXVhbGl0eShibG9iLCBxdWFsaXR5LCBtYXhTaXplSW5NQiwgY3VycmVudFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrQ29tcHJlc3Npb25TdGF0dXMoY3ZzLCBibG9iLCBxdWFsaXR5LCBtYXhTaXplSW5NQiwgY3VycmVudFN0ZXAsIG5ld1F1YWxpdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBcImltYWdlL2pwZWdcIiwgcXVhbGl0eSAvIDEwMCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5wcm90b3R5cGUuZ2V0UmVzdWx0RmlsZSA9IGZ1bmN0aW9uIChibG9iKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXN1bHRGaWxlKGJsb2IsIHRoaXMuaW5pdGlhbEZpbGUubmFtZSwgdGhpcy5pbml0aWFsRmlsZS50eXBlLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcbiAgICB9O1xyXG4gICAgSW1nTWF4U2l6ZVNlcnZpY2UucHJvdG90eXBlLmdlbmVyYXRlUmVzdWx0RmlsZSA9IGZ1bmN0aW9uIChibG9iLCBuYW1lLCB0eXBlLCBsYXN0TW9kaWZpZWQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0RmlsZSA9IG5ldyBCbG9iKFtibG9iXSwgeyB0eXBlOiB0eXBlIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2JUb0ZpbGUocmVzdWx0RmlsZSwgbmFtZSwgbGFzdE1vZGlmaWVkKTtcclxuICAgIH07XHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5wcm90b3R5cGUuYmxvYlRvRmlsZSA9IGZ1bmN0aW9uIChibG9iLCBuYW1lLCBsYXN0TW9kaWZpZWQpIHtcclxuICAgICAgICB2YXIgZmlsZSA9IGJsb2I7XHJcbiAgICAgICAgZmlsZS5uYW1lID0gbmFtZTtcclxuICAgICAgICBmaWxlLmxhc3RNb2RpZmllZCA9IGxhc3RNb2RpZmllZDtcclxuICAgICAgICAvL0Nhc3QgdG8gYSBGaWxlKCkgdHlwZVxyXG4gICAgICAgIHJldHVybiBmaWxlO1xyXG4gICAgfTtcclxuICAgIEltZ01heFNpemVTZXJ2aWNlLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkUXVhbGl0eSA9IGZ1bmN0aW9uIChibG9iLCBxdWFsaXR5LCBtYXhTaXplSW5NQiwgY3VycmVudFN0ZXApIHtcclxuICAgICAgICAvL0NBTENVTEFURSBORVcgUVVBTElUWVxyXG4gICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IGJsb2Iuc2l6ZSAvIDEwMjQgLyAxMDI0O1xyXG4gICAgICAgIHZhciByYXRpb01heFNpemVUb0N1cnJlbnRTaXplID0gbWF4U2l6ZUluTUIgLyBjdXJyZW50U2l6ZTtcclxuICAgICAgICBpZiAocmF0aW9NYXhTaXplVG9DdXJyZW50U2l6ZSA+IDUpIHtcclxuICAgICAgICAgICAgLy9tYXggcmF0aW8gdG8gYXZvaWQgZXh0cmVtZSBxdWFsaXR5IHZhbHVlc1xyXG4gICAgICAgICAgICByYXRpb01heFNpemVUb0N1cnJlbnRTaXplID0gNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJhdGlvTWF4U2l6ZVRvSW5pdGlhbFNpemUgPSBjdXJyZW50U2l6ZSAvICh0aGlzLmluaXRpYWxGaWxlLnNpemUgLyAxMDI0IC8gMTAyNCk7XHJcbiAgICAgICAgaWYgKHJhdGlvTWF4U2l6ZVRvSW5pdGlhbFNpemUgPCAwLjA1KSB7XHJcbiAgICAgICAgICAgIC8vbWluIHJhdGlvIHRvIGF2b2lkIGV4dHJlbWUgcXVhbGl0eSB2YWx1ZXNcclxuICAgICAgICAgICAgcmF0aW9NYXhTaXplVG9Jbml0aWFsU2l6ZSA9IDAuMDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdRdWFsaXR5ID0gMDtcclxuICAgICAgICB2YXIgbXVsdGlwbGljYXRvciA9IE1hdGguYWJzKHJhdGlvTWF4U2l6ZVRvSW5pdGlhbFNpemUgLSAxKSAqIDEwIC8gKGN1cnJlbnRTdGVwICogMS43KSAvIHJhdGlvTWF4U2l6ZVRvQ3VycmVudFNpemU7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpY2F0b3IgPCAxKSB7XHJcbiAgICAgICAgICAgIG11bHRpcGxpY2F0b3IgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF0aW9NYXhTaXplVG9DdXJyZW50U2l6ZSA+PSAxKSB7XHJcbiAgICAgICAgICAgIG5ld1F1YWxpdHkgPSBxdWFsaXR5ICsgKHJhdGlvTWF4U2l6ZVRvQ3VycmVudFNpemUgLSAxKSAqIDEwICogbXVsdGlwbGljYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1F1YWxpdHkgPSBxdWFsaXR5IC0gKDEgLSByYXRpb01heFNpemVUb0N1cnJlbnRTaXplKSAqIDEwICogbXVsdGlwbGljYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld1F1YWxpdHkgPiAxMDApIHtcclxuICAgICAgICAgICAgLy9tYXggcXVhbGl0eSA9IDEwMCwgc28gbGV0J3Mgc2V0IHRoZSBuZXcgcXVhbGl0eSB0byB0aGUgdmFsdWUgaW4gYmV0d2VlbiB0aGUgb2xkIHF1YWxpdHkgYW5kIDEwMCBpbiBjYXNlIG9mID4gMTAwXHJcbiAgICAgICAgICAgIG5ld1F1YWxpdHkgPSBxdWFsaXR5ICsgKDEwMCAtIHF1YWxpdHkpIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5ld1F1YWxpdHkgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vbWluIHF1YWxpdHkgPSAwLCBzbyBsZXQncyBzZXQgdGhlIG5ldyBxdWFsaXR5IHRvIHRoZSB2YWx1ZSBpbiBiZXR3ZWVuIHRoZSBvbGQgcXVhbGl0eSBhbmQgMCBpbiBjYXNlIG9mIDwgMFxyXG4gICAgICAgICAgICBuZXdRdWFsaXR5ID0gcXVhbGl0eSAtIHF1YWxpdHkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UXVhbGl0eTtcclxuICAgIH07XHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5wcm90b3R5cGUuY2hlY2tDb21wcmVzc2lvblN0YXR1cyA9IGZ1bmN0aW9uIChjdnMsIGJsb2IsIHF1YWxpdHksIG1heFNpemVJbk1CLCBjdXJyZW50U3RlcCwgbmV3UXVhbGl0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHF1YWxpdHkgPT09IDEwMCAmJiBuZXdRdWFsaXR5ID49IDEwMCkge1xyXG4gICAgICAgICAgICAgICAgLy9DT01QUkVTU0lPTiBFTkRcclxuICAgICAgICAgICAgICAgIC8vU2VlbXMgbGlrZSBxdWFsaXR5IDEwMCBpcyBtYXggYnV0IGZpbGUgc3RpbGwgdG9vIHNtYWxsLCBjYXNlIHRoYXQgc2hvdWxkbid0IGV4aXN0IGFzIHRoZSBjb21wcmVzc2lvbiBzaG91bGRuJ3QgZXZlbiBoYXZlIHN0YXJ0ZWQgaW4gdGhlIGZpcnN0IHBsYWNlXHJcbiAgICAgICAgICAgICAgICByZWplY3QoeyBjb21wcmVzc2VkRmlsZTogX3RoaXMuaW5pdGlhbEZpbGUsIHJlYXNvbjogXCJVbmZvcnR1bmF0ZWx5IHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjb21wcmVzc2luZyB0aGUgZmlsZS5cIiwgZXJyb3I6IFwiRklMRV9CSUdHRVJfVEhBTl9JTklUSUFMX0ZJTEVcIiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocXVhbGl0eSA8IDEpICYmIChuZXdRdWFsaXR5IDwgcXVhbGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIC8vQ09NUFJFU1NJT04gRU5EXHJcbiAgICAgICAgICAgICAgICAvL0ZpbGUgc2l6ZSBzdGlsbCB0b28gYmlnIGJ1dCBjYW4ndCBjb21wcmVzcyBmdXJ0aGVyIHRoYW4gcXVhbGl0eT0wXHJcbiAgICAgICAgICAgICAgICByZWplY3QoeyBjb21wcmVzc2VkRmlsZTogX3RoaXMuZ2V0UmVzdWx0RmlsZShibG9iKSwgcmVhc29uOiBcIkNvdWxkIG5vdCBjb21wcmVzcyBpbWFnZSBlbm91Z2ggdG8gZml0IHRoZSBtYXhpbWFsIGZpbGUgc2l6ZSBsaW1pdC5cIiwgZXJyb3I6IFwiVU5BQkxFX1RPX0NPTVBSRVNTX0VOT1VHSFwiIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChuZXdRdWFsaXR5ID4gcXVhbGl0eSkgJiYgKE1hdGgucm91bmQocXVhbGl0eSkgPT0gTWF0aC5yb3VuZChuZXdRdWFsaXR5KSkpIHtcclxuICAgICAgICAgICAgICAgIC8vQ09NUFJFU1NJT04gRU5EXHJcbiAgICAgICAgICAgICAgICAvL25leHQgc3RlcHMgcXVhbGl0eSB3b3VsZCBiZSB0aGUgc2FtZSBxdWFsaXR5IGJ1dCBuZXdRdWFsaXR5IGlzIHNsaWdodGx5IGJpZ2dlciB0aGFuIG9sZCBvbmUsIG1lYW5zIHdlIG1vc3QgbGlrZWx5IGZvdW5kIHRoZSBuZWFyZXN0IHF1YWxpdHkgdG8gY29tcHJlc3MgdG8gbWF4aW1hbCBzaXplXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmdldFJlc3VsdEZpbGUoYmxvYikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRTdGVwID4gNSAmJiAobmV3UXVhbGl0eSA+IHF1YWxpdHkpICYmIChuZXdRdWFsaXR5IDwgcXVhbGl0eSArIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0NPTVBSRVNTSU9OIEVORFxyXG4gICAgICAgICAgICAgICAgLy9mb3Igc29tZSByYXJlIG9jY2FzaW9ucyB0aGUgYWxnb3JpdGhtIG1pZ2h0IGJlIHN0dWNrIGFyb3VuZCBlLmcuIDk4LjUgYW5kIDk3LjQgYmVjYXVzZSBvZiB0aGUgbWF4UXVhbGl0eSBvZiAxMDAsIHRoZSBjdXJyZW50IHF1YWxpdHkgaXMgdGhlIG5lYXJlc3QgcG9zc2libGUgcXVhbGl0eSBpbiB0aGF0IGNhc2VcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuZ2V0UmVzdWx0RmlsZShibG9iKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKG5ld1F1YWxpdHkgPiBxdWFsaXR5KSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHF1YWxpdHkpICYmIChNYXRoLmZsb29yKG5ld1F1YWxpdHkpID09IHF1YWxpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAvL0NPTVBSRVNTSU9OIEVORFxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICBpbiB0aGUgcHJldmlvdXMgc3RlcCBpZiAoKHF1YWxpdHkgPiBuZXdRdWFsaXR5KSAmJiAoTWF0aC5yb3VuZChxdWFsaXR5KSA9PSBNYXRoLnJvdW5kKG5ld1F1YWxpdHkpKSkgYXBwbGllZCwgc29cclxuICAgICAgICAgICAgICAgICAgICBuZXdRdWFsaXR5ID0gTWF0aC5yb3VuZChuZXdRdWFsaXR5KSAtIDE7IHRoaXMgd2FzIGRvbmUgdG8gcmVkdWNlIHRoZSBxdWFsaXR5IGF0IGxlYXN0IGEgZnVsbCBpbnRlZ2VyIGRvd24gdG8gbm90IHdhc3RlIGEgc3RlcFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIHNhbWUgY29tcHJlc3Npb24gcmF0ZSBxdWFsaXR5IGFzIGJlZm9yZS4gTm93LCB0aGUgbmV3UXVhbGl0eSBpcyBzdGlsbCBvbmx5IGluIGJldHdlZW4gdGhlIG9sZCBxdWFsaXR5IChlLmcuIDkzKVxyXG4gICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgbmV3UXVhbGl0eSAoZS5nLiA5NCkgd2hpY2ggbW9zdCBsaWtlbHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSBuZXdRdWFsaXR5ICh0aGUgYmlnZ2VyIG9uZSkgd291bGQgbWFrZSB0aGUgZmlsZXNpemVcclxuICAgICAgICAgICAgICAgICAgICB0b28gYmlnIHNvIHdlIHNob3VsZCBqdXN0IHN0aWNrIHdpdGggdGhlIGN1cnJlbnQsIGxvd2VyIHF1YWxpdHkgYW5kIHJldHVybiB0aGF0IGZpbGUuXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5nZXRSZXN1bHRGaWxlKGJsb2IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vQ09OVElOVUUgQ09NUFJFU1NJT05cclxuICAgICAgICAgICAgICAgIGlmICgocXVhbGl0eSA+IG5ld1F1YWxpdHkpICYmIChNYXRoLnJvdW5kKHF1YWxpdHkpID09IE1hdGgucm91bmQobmV3UXVhbGl0eSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9xdWFsaXR5IGNhbiBvbmx5IGJlIGFuIGludGVnZXIgLT4gbWFrZSBzdXJlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbGQgcXVhbGl0eSBhbmQgbmV3IG9uZSBpcyBhdCBsZWFzdCBhIHdob2xlIGludGVnZXIgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBpdCB3b3VsZCBiZSBub25zZW5zZSB0byBjb21wcmVzcyBhZ2FpbiB3aXRoIHRoZSBzYW1lIHF1YWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBuZXdRdWFsaXR5ID0gTWF0aC5yb3VuZChuZXdRdWFsaXR5KSAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3JlY3Vyc2l2ZWx5IGNhbGwgZnVuY3Rpb24gYWdhaW5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuZ2V0Q29tcHJlc3NlZEZpbGUoY3ZzLCBuZXdRdWFsaXR5LCBtYXhTaXplSW5NQiwgY3VycmVudFN0ZXAgKyAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIEltZ01heFNpemVTZXJ2aWNlLnByb3RvdHlwZS5pc0ltZ1VzaW5nQWxwaGEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZURhdGEuZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbaSArIDNdICE9PSAyNTUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5wcm90b3R5cGUubG9nRXhlY3V0aW9uVGltZSA9IGZ1bmN0aW9uIChsb2dFeGVjdXRpb25UaW1lKSB7XHJcbiAgICAgICAgaWYgKGxvZ0V4ZWN1dGlvblRpbWUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiRXhlY3V0aW9uIHRpbWU6IFwiLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMudGltZUF0U3RhcnQgKyBcIm1zXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBJbWdNYXhTaXplU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcclxuICAgICAgICB7IHR5cGU6IEltZ0V4aWZTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBJbWdFeGlmU2VydmljZTsgfSksXSB9XSB9XHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIEltZ01heFNpemVTZXJ2aWNlO1xyXG59KCkpO1xuXG52YXIgSW1nTWF4UFhTaXplU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEltZ01heFBYU2l6ZVNlcnZpY2UobmcyUGljYVNlcnZpY2UsIGltYWdlRXhpZlNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLm5nMlBpY2FTZXJ2aWNlID0gbmcyUGljYVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5pbWFnZUV4aWZTZXJ2aWNlID0gaW1hZ2VFeGlmU2VydmljZTtcclxuICAgIH1cclxuICAgIEltZ01heFBYU2l6ZVNlcnZpY2UucHJvdG90eXBlLnJlc2l6ZUltYWdlID0gZnVuY3Rpb24gKGZpbGUsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGxvZ0V4ZWN1dGlvblRpbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChsb2dFeGVjdXRpb25UaW1lID09PSB2b2lkIDApIHsgbG9nRXhlY3V0aW9uVGltZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHJlc2l6ZWRGaWxlU3ViamVjdCA9IG5ldyByeGpzLlN1YmplY3QoKTtcclxuICAgICAgICB0aGlzLnRpbWVBdFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgaWYgKGZpbGUudHlwZSAhPT0gXCJpbWFnZS9qcGVnXCIgJiYgZmlsZS50eXBlICE9PSBcImltYWdlL3BuZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vRU5EIE9GIFJFU0laRVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlc2l6ZWRGaWxlU3ViamVjdC5lcnJvcih7IHJlc2l6ZWRGaWxlOiBmaWxlLCByZWFzb246IFwiVGhlIHByb3ZpZGVkIEZpbGUgaXMgbmVpdGhlciBvZiB0eXBlIGpwZyBub3Igb2YgdHlwZSBwbmcuXCIsIGVycm9yOiBcIklOVkFMSURfRVhURU5TSU9OXCIgfSk7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzaXplZEZpbGVTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmltYWdlRXhpZlNlcnZpY2UuZ2V0T3JpZW50ZWRJbWFnZShpbWcpLnRoZW4oZnVuY3Rpb24gKG9yaWVudGVkSW1nKSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChpbWcuc3JjKTtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50V2lkdGggPSBvcmllbnRlZEltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SGVpZ2h0ID0gb3JpZW50ZWRJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gY3VycmVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0hlaWdodCA9IGN1cnJlbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3V2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gbWF4V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXNpemUgaGVpZ2h0IHByb3BvcnRpb25hbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gbWF4V2lkdGggLyBjdXJyZW50V2lkdGg7IC8vaXMgZ29ubmEgYmUgPDFcclxuICAgICAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgKiByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3SGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzaXplIHdpZHRoIHByb3BvcnRpb25hbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gbWF4SGVpZ2h0IC8gY3VycmVudEhlaWdodDsgLy9pcyBnb25uYSBiZSA8MVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggKiByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdIZWlnaHQgPT09IG9yaWVudGVkSW1nLmhlaWdodCAmJiBuZXdXaWR0aCA9PT0gb3JpZW50ZWRJbWcud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL25vIHJlc2l6aW5nIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZWRGaWxlU3ViamVjdC5uZXh0KGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nRXhlY3V0aW9uVGltZShsb2dFeGVjdXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmcyUGljYVNlcnZpY2UucmVzaXplKFtmaWxlXSwgbmV3V2lkdGgsIG5ld0hlaWdodCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbGwgZ29vZCwgcmVzdWx0IGlzIGEgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemVkRmlsZVN1YmplY3QubmV4dChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZ0V4ZWN1dGlvblRpbWUobG9nRXhlY3V0aW9uVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc29tZXRoaW5nIHdlbnQgd3JvbmcgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZWRGaWxlU3ViamVjdC5lcnJvcih7IHJlc2l6ZWRGaWxlOiBmaWxlLCByZWFzb246IGVycm9yLCBlcnJvcjogXCJQSUNBX0VSUk9SXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nRXhlY3V0aW9uVGltZShsb2dFeGVjdXRpb25UaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpbWcuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc2l6ZWRGaWxlU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIEltZ01heFBYU2l6ZVNlcnZpY2UucHJvdG90eXBlLmxvZ0V4ZWN1dGlvblRpbWUgPSBmdW5jdGlvbiAobG9nRXhlY3V0aW9uVGltZSkge1xyXG4gICAgICAgIGlmIChsb2dFeGVjdXRpb25UaW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkV4ZWN1dGlvbiB0aW1lOiBcIiwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVBdFN0YXJ0ICsgXCJtc1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW1nTWF4UFhTaXplU2VydmljZS5kZWNvcmF0b3JzID0gW1xyXG4gICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXHJcbiAgICBdO1xyXG4gICAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgICBJbWdNYXhQWFNpemVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xyXG4gICAgICAgIHsgdHlwZTogbmcyUGljYS5OZzJQaWNhU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmcyUGljYS5OZzJQaWNhU2VydmljZTsgfSksXSB9XSB9LFxyXG4gICAgICAgIHsgdHlwZTogSW1nRXhpZlNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEltZ0V4aWZTZXJ2aWNlOyB9KSxdIH1dIH1cclxuICAgIF07IH07XHJcbiAgICByZXR1cm4gSW1nTWF4UFhTaXplU2VydmljZTtcclxufSgpKTtcblxudmFyIE5nMkltZ01heFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZzJJbWdNYXhTZXJ2aWNlKGltZ01heFNpemVTZXJ2aWNlLCBpbWdNYXhQWFNpemVTZXJ2aWNlLCBpbWFnZUV4aWZTZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5pbWdNYXhTaXplU2VydmljZSA9IGltZ01heFNpemVTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuaW1nTWF4UFhTaXplU2VydmljZSA9IGltZ01heFBYU2l6ZVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5pbWFnZUV4aWZTZXJ2aWNlID0gaW1hZ2VFeGlmU2VydmljZTtcclxuICAgIH1cclxuICAgIE5nMkltZ01heFNlcnZpY2UucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGZpbGVzLCBtYXhTaXplSW5NQiwgaWdub3JlQWxwaGEsIGxvZ0V4ZWN1dGlvblRpbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChpZ25vcmVBbHBoYSA9PT0gdm9pZCAwKSB7IGlnbm9yZUFscGhhID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobG9nRXhlY3V0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGxvZ0V4ZWN1dGlvblRpbWUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBjb21wcmVzc2VkRmlsZVN1YmplY3QgPSBuZXcgcnhqcy5TdWJqZWN0KCk7XHJcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5jb21wcmVzc0ltYWdlKGZpbGUsIG1heFNpemVJbk1CLCBpZ25vcmVBbHBoYSwgbG9nRXhlY3V0aW9uVGltZSkuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcHJlc3NlZEZpbGVTdWJqZWN0Lm5leHQodmFsdWUpO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbXByZXNzZWRGaWxlU3ViamVjdC5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wcmVzc2VkRmlsZVN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB9O1xyXG4gICAgTmcySW1nTWF4U2VydmljZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGZpbGVzLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBsb2dFeGVjdXRpb25UaW1lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAobG9nRXhlY3V0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGxvZ0V4ZWN1dGlvblRpbWUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciByZXNpemVkRmlsZVN1YmplY3QgPSBuZXcgcnhqcy5TdWJqZWN0KCk7XHJcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5yZXNpemVJbWFnZShmaWxlLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBsb2dFeGVjdXRpb25UaW1lKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVkRmlsZVN1YmplY3QubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVzaXplZEZpbGVTdWJqZWN0LmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc2l6ZWRGaWxlU3ViamVjdC5hc09ic2VydmFibGUoKTtcclxuICAgIH07XHJcbiAgICBOZzJJbWdNYXhTZXJ2aWNlLnByb3RvdHlwZS5jb21wcmVzc0ltYWdlID0gZnVuY3Rpb24gKGZpbGUsIG1heFNpemVJbk1CLCBpZ25vcmVBbHBoYSwgbG9nRXhlY3V0aW9uVGltZSkge1xyXG4gICAgICAgIGlmIChpZ25vcmVBbHBoYSA9PT0gdm9pZCAwKSB7IGlnbm9yZUFscGhhID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobG9nRXhlY3V0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGxvZ0V4ZWN1dGlvblRpbWUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmltZ01heFNpemVTZXJ2aWNlLmNvbXByZXNzSW1hZ2UoZmlsZSwgbWF4U2l6ZUluTUIsIGlnbm9yZUFscGhhLCBsb2dFeGVjdXRpb25UaW1lKTtcclxuICAgIH07XHJcbiAgICBOZzJJbWdNYXhTZXJ2aWNlLnByb3RvdHlwZS5yZXNpemVJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBsb2dFeGVjdXRpb25UaW1lKSB7XHJcbiAgICAgICAgaWYgKGxvZ0V4ZWN1dGlvblRpbWUgPT09IHZvaWQgMCkgeyBsb2dFeGVjdXRpb25UaW1lID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbWdNYXhQWFNpemVTZXJ2aWNlLnJlc2l6ZUltYWdlKGZpbGUsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGxvZ0V4ZWN1dGlvblRpbWUpO1xyXG4gICAgfTtcclxuICAgIE5nMkltZ01heFNlcnZpY2UucHJvdG90eXBlLmdldEVYSUZPcmllbnRlZEltYWdlID0gZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VFeGlmU2VydmljZS5nZXRPcmllbnRlZEltYWdlKGltYWdlKTtcclxuICAgIH07XHJcbiAgICBOZzJJbWdNYXhTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXHJcbiAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcclxuICAgIF07XHJcbiAgICAvKiogQG5vY29sbGFwc2UgKi9cclxuICAgIE5nMkltZ01heFNlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXHJcbiAgICAgICAgeyB0eXBlOiBJbWdNYXhTaXplU2VydmljZSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gSW1nTWF4U2l6ZVNlcnZpY2U7IH0pLF0gfV0gfSxcclxuICAgICAgICB7IHR5cGU6IEltZ01heFBYU2l6ZVNlcnZpY2UsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEltZ01heFBYU2l6ZVNlcnZpY2U7IH0pLF0gfV0gfSxcclxuICAgICAgICB7IHR5cGU6IEltZ0V4aWZTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBJbWdFeGlmU2VydmljZTsgfSksXSB9XSB9XHJcbiAgICBdOyB9O1xyXG4gICAgcmV0dXJuIE5nMkltZ01heFNlcnZpY2U7XHJcbn0oKSk7XG5cbnZhciBOZzJJbWdNYXhNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZzJJbWdNYXhNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBOZzJJbWdNYXhNb2R1bGUuZGVjb3JhdG9ycyA9IFtcclxuICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZzJQaWNhLk5nMlBpY2FNb2R1bGVcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEltZ01heFBYU2l6ZVNlcnZpY2UsIHVzZUNsYXNzOiBJbWdNYXhQWFNpemVTZXJ2aWNlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSW1nTWF4U2l6ZVNlcnZpY2UsIHVzZUNsYXNzOiBJbWdNYXhTaXplU2VydmljZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEltZ0V4aWZTZXJ2aWNlLCB1c2VDbGFzczogSW1nRXhpZlNlcnZpY2UgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOZzJJbWdNYXhTZXJ2aWNlLCB1c2VDbGFzczogTmcySW1nTWF4U2VydmljZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgfSxdIH0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIE5nMkltZ01heE1vZHVsZTtcclxufSgpKTtcblxuZXhwb3J0cy5OZzJJbWdNYXhTZXJ2aWNlID0gTmcySW1nTWF4U2VydmljZTtcbmV4cG9ydHMuTmcySW1nTWF4TW9kdWxlID0gTmcySW1nTWF4TW9kdWxlO1xuZXhwb3J0cy5JbWdNYXhTaXplU2VydmljZSA9IEltZ01heFNpemVTZXJ2aWNlO1xuZXhwb3J0cy5JbWdNYXhQWFNpemVTZXJ2aWNlID0gSW1nTWF4UFhTaXplU2VydmljZTtcbmV4cG9ydHMuSW1nRXhpZlNlcnZpY2UgPSBJbWdFeGlmU2VydmljZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdfQ==